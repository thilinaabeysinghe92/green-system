{"version":3,"sources":["webpack:///ml-optimize-lorentzian/webpack/universalModuleDefinition","webpack:///ml-optimize-lorentzian/ml-optimize-lorentzian.min.js","webpack:///ml-optimize-lorentzian/webpack/bootstrap 5ab31adfc0ecf3479ba1","webpack:///ml-optimize-lorentzian/./src/index.js","webpack:///ml-optimize-lorentzian/./~/ml-curve-fitting/src/index.js","webpack:///ml-optimize-lorentzian/./~/ml-curve-fitting/src/LM.js","webpack:///ml-optimize-lorentzian/./~/ml-matrix/src/index.js","webpack:///ml-optimize-lorentzian/./~/ml-matrix/src/matrix.js","webpack:///ml-optimize-lorentzian/./~/ml-matrix/src/decompositions.js","webpack:///ml-optimize-lorentzian/./~/ml-matrix/src/dc/svd.js","webpack:///ml-optimize-lorentzian/./~/ml-matrix/src/dc/util.js","webpack:///ml-optimize-lorentzian/./~/ml-matrix/src/dc/evd.js","webpack:///ml-optimize-lorentzian/./~/ml-matrix/src/dc/lu.js","webpack:///ml-optimize-lorentzian/./~/ml-matrix/src/dc/qr.js","webpack:///ml-optimize-lorentzian/./~/ml-matrix/src/dc/cholesky.js","webpack:///ml-optimize-lorentzian/./~/ml-curve-fitting/src/algebra.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","sumOfLorentzians","t","factor","i","j","p2","nL","length","cols","rows","result","Matrix","zeros","Math","pow","singleLorentzian","columns","singleGaussian","factor2","exp","optimizeSingleLorentzian","xy","peak","opts","xy2","parseData","percentage","y_data","maxY","nbPoints","weight","sqrt","dot","Object","create","LMOptions","consts","dt","abs","dx","p_init","x","width","p_min","p_max","p_fit","LM","optimize","optimizeSingleGaussian","optimizeLorentzianTrain","group","nextX","tI","yI","current","currentIndex","push","y","opt","optimizeGaussianTrain","optimizeLorentzianSum","math","Array","optimizeGaussianSum","k","threshold","nbSeries","splice","transpose","algebra","func","y_dat","dp","tensor_parameter","iteration","eps","Npar","Npnt","p_old","y_old","X2","X2_old","J","console","log","length_t","length_y_dat","multiply","prnt","MaxIter","epsilon_1","epsilon_4","lambda_0","lambda_UP_fac","lambda_DN_fac","Update_Type","dp_array","idx","Nfit","stop","weight_sq","tmp","ones","dotMultiply","lm_matx","JtWJ","JtWdy","Chi_sq","y_hat","max","lambda","diag","nu","h","solve","add","eye","hidx","p_try","min","delta_y","subtract","X2_try","JtWdy_th","alpha","inv","mat","rho","dX2","apply","lm_FD_J","n","ps","clone","del","y1","column","dotDivide","lm_Broyden_J","h_t","div","Jt","Decompositions","DC","slice","arr","ii","nRows","nColumns","matrix","newInstance","isArray","TypeError","RangeError","defineProperty","writable","value","__proto__","prototype","Asplice","Aconcat","concat","from1DArray","newRows","newColumns","newData","data","rowVector","columnVector","l","vector","empty","fill","rand","jj","random","indices","from","to","stack","arg1","isMatrix","arguments","r","setRow","expand","base","count","expansion","checkMatrix","klass","get","checkRowIndex","index","checkColumnIndex","checkDimensions","otherMatrix","callback","to2DArray","to1DArray","copy","isRowVector","isColumnVector","isVector","isSquare","isSymmetric","set","rowIndex","columnIndex","neg","mulS","addS","addM","sub","subS","subM","mul","mulM","divS","divM","getRow","getRowVector","array","removeRow","addRow","swapRows","row1","row2","temp","getColumn","getColumnVector","setColumn","removeColumn","addColumn","swapColumns","column1","column2","row","checkRowVector","checkColumnVector","addRowVector","subRowVector","mulRowVector","divRowVector","addColumnVector","subColumnVector","mulColumnVector","divColumnVector","mulRow","mulColumn","v","Infinity","maxIndex","minIndex","maxRow","maxRowIndex","minRow","minRowIndex","maxColumn","maxColumnIndex","minColumn","minColumnIndex","sum","mean","size","prod","cumulativeSum","other","vector1","vector2","mmul","warn","Bcolj","Arowi","s","sortRows","compareFunction","sort","sortColumns","subMatrix","startRow","endRow","startColumn","endColumn","newMatrix","subMatrixRow","X","subMatrixColumn","trace","inverse","leftHandSide","rightHandSide","LuDecomposition","QrDecomposition","SingularValueDecomposition","EigenvalueDecomposition","CholeskyDecomposition","SVD","EVD","LU","QR","CHO","options","a","wantu","wantv","computeLeftSingularVectors","computeRightSingularVectors","autoTranspose","swapped","aux","ks","f","cs","sn","kase","scale","sp","spm1","epm1","sk","ek","b","shift","g","U","V","e","work","nct","nrt","hypotenuse","pp","iter","condition","norm2","rank","tol","diagonal","leftSingularVectors","rightSingularVectors","diagonalMatrix","Y","scols","Ls","VL","vrows","urows","VLU","solveForDiagonal","vcols","ucols","Error","d","tred2","tql2","H","ort","orthes","hqr2","hh","dl1","c2","c3","el1","s2","tst1","low","high","nn","w","ra","sa","vr","vi","notlast","cdivres","exshift","norm","q","z","cdiv","xr","xi","yr","yi","realEigenvalues","imaginaryEigenvalues","eigenvectorMatrix","LUrowi","LUcolj","kmax","lu","pivotVector","pivotSign","isSingular","col","determinant","lowerTriangularFactor","upperTriangularFactor","pivotPermutationVector","qr","rdiag","nrm","Rdiag","isFullRank","orthogonalFactor","dimension","positiveDefinite","Lrowj","Lrowk","L","leftTriangularFactor","B","A","dotPow"],"mappings":"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","file":"ml-optimize-lorentzian.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"mlOptimizeLorentzian\"] = factory();\n\telse\n\t\troot[\"mlOptimizeLorentzian\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"mlOptimizeLorentzian\"] = factory();\n\telse\n\t\troot[\"mlOptimizeLorentzian\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar LM = __webpack_require__(1);\n\tvar math = LM.Matrix.algebra;\n\tvar Matrix = __webpack_require__(3);\n\t\n\t/**\n\t * This function calculates the spectrum as a sum of lorentzian functions. The Lorentzian\n\t * parameters are divided in 3 batches. 1st: centers; 2nd: heights; 3th: widths;\n\t * @param t Ordinate values\n\t * @param p Lorentzian parameters\n\t * @param c Constant parameters(Not used)\n\t * @returns {*}\n\t */\n\tfunction sumOfLorentzians(t,p,c){\n\t    var nL = p.length/3,factor,i, j,p2, cols = t.rows;\n\t    var result = Matrix.zeros(t.length,1);\n\t\n\t    for(i=0;i<nL;i++){\n\t        p2 = Math.pow(p[i+nL*2][0]/2,2);\n\t        factor = p[i+nL][0]*p2;\n\t        for(j=0;j<cols;j++){\n\t            result[j][0]+=factor/(Math.pow(t[j][0]-p[i][0],2)+p2);\n\t        }\n\t    }\n\t    return result;\n\t}\n\t\n\t/**\n\t * This function calculates the spectrum as a sum of gaussian functions. The Gaussian\n\t * parameters are divided in 3 batches. 1st: centers; 2nd: height; 3th: std's;\n\t * @param t Ordinate values\n\t * @param p Gaussian parameters\n\t * @param c Constant parameters(Not used)\n\t * @returns {*}\n\t */\n\tfunction sumOfGaussians(t,p,c){\n\t    var nL = p.length/3,factor,i, j, cols = t.rows;\n\t    var result = Matrix.zeros(t.length,1);\n\t\n\t    for(i=0;i<nL;i++){\n\t        factor = p[i+nL*2][0]*p[i+nL*2][0]/2;\n\t        for(j=0;j<cols;j++){\n\t            result[j][0]+=p[i+nL][0]*Math.exp(-(t[i][0]-p[i][0])*(t[i][0]-p[i][0])/factor);\n\t        }\n\t    }\n\t    return result;\n\t}\n\t/**\n\t * Single 4 parameter lorentzian function\n\t * @param t Ordinate values\n\t * @param p Lorentzian parameters\n\t * @param c Constant parameters(Not used)\n\t * @returns {*}\n\t */\n\tfunction singleLorentzian(t,p,c){\n\t    var factor = p[1][0]*Math.pow(p[2][0]/2,2);\n\t    var rows = t.rows;\n\t    var result = new Matrix(t.rows, t.columns);\n\t    for(var i=0;i<rows;i++){\n\t        result[i][0]=factor/(Math.pow(t[i][0]-p[0][0],2)+Math.pow(p[2][0]/2,2));\n\t    }\n\t    return result;\n\t}\n\t\n\t/**\n\t * Single 3 parameter gaussian function\n\t * @param t Ordinate values\n\t * @param p Gaussian parameters [mean, height, std]\n\t * @param c Constant parameters(Not used)\n\t * @returns {*}\n\t */\n\tfunction singleGaussian(t,p,c){\n\t    var factor2 = p[2][0]*p[2][0]/2;\n\t    var rows = t.rows;\n\t    var result = new Matrix(t.rows, t.columns);\n\t    for(var i=0;i<rows;i++){\n\t        result[i][0]=p[1][0]*Math.exp(-(t[i][0]-p[0][0])*(t[i][0]-p[0][0])/factor2);\n\t    }\n\t    return result;\n\t}\n\t\n\t/**\n\t * * Fits a set of points to a Lorentzian function. Returns the center of the peak, the width at half height, and the height of the signal.\n\t * @param data,[y]\n\t * @returns {*[]}\n\t */\n\tfunction optimizeSingleLorentzian(xy, peak, opts) {\n\t    opts = opts || {};\n\t    var xy2 = parseData(xy, opts.percentage||0);\n\t\n\t    if(xy2===null||xy2[0].rows<3){\n\t        return null; //Cannot run an optimization with less than 3 points\n\t    }\n\t\n\t    var t = xy2[0];\n\t    var y_data = xy2[1];\n\t    var maxY = xy2[2];\n\t    var nbPoints = t.rows, i;\n\t\n\t    var weight = [nbPoints / Math.sqrt(y_data.dot(y_data))];\n\t\n\t    var opts=Object.create(opts.LMOptions || [  3,    100, 1e-3, 1e-3, 1e-3, 1e-2, 1e-2,    11,    9,        1 ]);\n\t    //var opts = [  3,    100, 1e-3, 1e-3, 1e-3, 1e-2, 1e-2,    11,    9,        1 ];\n\t    var consts = [ ];\n\t    var dt = Math.abs(t[0][0]-t[1][0]);// optional vector of constants\n\t    var dx = new Matrix([[-dt/10000],[-1e-3],[-dt/10000]]);//-Math.abs(t[0][0]-t[1][0])/100;\n\t    var p_init = new Matrix([[peak.x],[1],[peak.width]]);\n\t    var p_min = new Matrix([[peak.x-dt],[0.75],[peak.width/4]]);\n\t    var p_max = new Matrix([[peak.x+dt],[1.25],[peak.width*4]]);\n\t\n\t    var p_fit = LM.optimize(singleLorentzian,p_init,t,y_data,weight,dx,p_min,p_max,consts,opts);\n\t\n\t\n\t    p_fit = p_fit.p;\n\t    return [p_fit[0],[p_fit[1][0]*maxY],p_fit[2]];\n\t\n\t}\n\t\n\t/**\n\t * Fits a set of points to a gaussian bell. Returns the mean of the peak, the std and the height of the signal.\n\t * @param data,[y]\n\t * @returns {*[]}\n\t */\n\tfunction optimizeSingleGaussian(xy, peak, opts) {\n\t    opts = opts || {};\n\t    var xy2 = parseData(xy, opts.percentage||0);\n\t\n\t    if(xy2===null||xy2[0].rows<3){\n\t        return null; //Cannot run an optimization with less than 3 points\n\t    }\n\t\n\t    var t = xy2[0];\n\t    var y_data = xy2[1];\n\t    var maxY = xy2[2];\n\t\n\t    var nbPoints = t.rows, i;\n\t\n\t\n\t\n\t    var weight = [nbPoints / Math.sqrt(y_data.dot(y_data))];\n\t\n\t    var opts=Object.create(opts.LMOptions || [  3,    100, 1e-3, 1e-3, 1e-3, 1e-2, 1e-2,    11,    9,        1 ]);\n\t    //var opts = [  3,    100, 1e-3, 1e-3, 1e-3, 1e-2, 1e-2,    11,    9,        1 ];\n\t    var consts = [ ];                         // optional vector of constants\n\t    var dt = Math.abs(t[0][0]-t[1][0]);\n\t    var dx = new Matrix([[-dt/10000],[-1e-3],[-dt/10000]]);//-Math.abs(t[0][0]-t[1][0])/100;\n\t\n\t    var dx = new Matrix([[-Math.abs(t[0][0]-t[1][0])/1000],[-1e-3],[-peak.width/1000]]);\n\t    var p_init = new Matrix([[peak.x],[1],[peak.width]]);\n\t    var p_min = new Matrix([[peak.x-dt],[0.75],[peak.width/4]]);\n\t    var p_max = new Matrix([[peak.x+dt],[1.25],[peak.width*4]]);\n\t    //var p_min = new Matrix([[peak.x-peak.width/4],[0.75],[peak.width/3]]);\n\t    //var p_max = new Matrix([[peak.x+peak.width/4],[1.25],[peak.width*3]]);\n\t\n\t    var p_fit = LM.optimize(singleGaussian,p_init,t,y_data,weight,dx,p_min,p_max,consts,opts);\n\t    p_fit = p_fit.p;\n\t    return [p_fit[0],[p_fit[1][0]*maxY],p_fit[2]];\n\t}\n\t\n\t/*\n\t peaks on group should sorted\n\t */\n\tfunction optimizeLorentzianTrain(xy, group, opts){\n\t    var xy2 = parseData(xy);\n\t    //console.log(xy2[0].rows);\n\t    if(xy2===null||xy2[0].rows<3){\n\t        return null; //Cannot run an optimization with less than 3 points\n\t    }\n\t\n\t    var t = xy2[0];\n\t    var y_data = xy2[1];\n\t    var maxY = xy2[2];\n\t    var currentIndex = 0;\n\t    var nbPoints = t.length;\n\t    var nextX;\n\t    var tI, yI, maxY;\n\t    var result=[], current;\n\t    for(var i=0; i<group.length;i++){\n\t        nextX = group[i].x-group[i].width*2;\n\t        //console.log(group[i]);\n\t        while(t[currentIndex++]<nextX&&currentIndex<nbPoints);\n\t        nextX = group[i].x+group[i].width*2;\n\t        tI = [];\n\t        yI = [];\n\t        while(t[currentIndex]<=nextX&&currentIndex<nbPoints){\n\t            tI.push(t[currentIndex][0]);\n\t            yI.push(y_data[currentIndex][0]*maxY);\n\t            currentIndex++;\n\t        }\n\t\n\t        current=optimizeSingleLorentzian([tI, yI], group[i], opts);\n\t        if(current){\n\t            result.push({\"x\":current[0][0],\"y\":current[1][0],\"width\":current[2][0],\"opt\":true});\n\t        }\n\t        else{\n\t            result.push({\"x\":group[i].x,\"y\":group[i].y,\"width\":group[i].width,\"opt\":false});\n\t        }\n\t    }\n\t\n\t    return result;\n\t\n\t}\n\t\n\tfunction optimizeGaussianTrain(xy, group, opts){\n\t    var xy2 = parseData(xy);\n\t    //console.log(xy2[0].rows);\n\t    if(xy2===null||xy2[0].rows<3){\n\t        return null; //Cannot run an optimization with less than 3 points\n\t    }\n\t\n\t    var t = xy2[0];\n\t    var y_data = xy2[1];\n\t    var maxY = xy2[2];\n\t    var currentIndex = 0;\n\t    var nbPoints = t.length;\n\t    var nextX;\n\t    var tI, yI, maxY;\n\t    var result=[], current;\n\t    for(var i=0; i<group.length;i++){\n\t        nextX = group[i].x-group[i].width*2;\n\t        //console.log(group[i]);\n\t        while(t[currentIndex++]<nextX&&currentIndex<nbPoints);\n\t        nextX = group[i].x+group[i].width*2;\n\t        tI = [];\n\t        yI = [];\n\t        while(t[currentIndex]<=nextX&&currentIndex<nbPoints){\n\t            tI.push(t[currentIndex][0]);\n\t            yI.push(y_data[currentIndex][0]*maxY);\n\t            currentIndex++;\n\t        }\n\t\n\t        current=optimizeSingleGaussian([tI, yI], group[i], opts);\n\t        if(current){\n\t            result.push({\"x\":current[0][0],\"y\":current[1][0],\"width\":current[2][0],\"opt\":true});\n\t        }\n\t        else{\n\t            result.push({\"x\":group[i].x,\"y\":group[i].y,\"width\":group[i].width,\"opt\":false});\n\t        }\n\t    }\n\t\n\t    return result;\n\t}\n\t\n\t\n\t\n\t/**\n\t *\n\t * @param xy A two column matrix containing the x and y data to be fitted\n\t * @param group A set of initial lorentzian parameters to be optimized [center, heigth, half_width_at_half_height]\n\t * @returns {Array} A set of final lorentzian parameters [center, heigth, hwhh*2]\n\t */\n\tfunction optimizeLorentzianSum(xy, group, opts){\n\t    var xy2 = parseData(xy);\n\t\n\t    if(xy2===null||xy2[0].rows<3){\n\t        return null; //Cannot run an optimization with less than 3 points\n\t    }\n\t\n\t    var t = xy2[0];\n\t    var y_data = xy2[1];\n\t    var maxY = xy2[2];\n\t    var nbPoints = t.rows, i;\n\t\n\t    var weight = [nbPoints / math.sqrt(y_data.dot(y_data))];\n\t    var opts=Object.create(opts || [  3,    100, 1e-3, 1e-3, 1e-3, 1e-2, 1e-2, 11, 9, 1 ]);\n\t    var consts = [ ];// optional vector of constants\n\t\n\t    var nL = group.length;\n\t    var p_init = new Matrix(nL*3,1);\n\t    var p_min =  new Matrix(nL*3,1);\n\t    var p_max =  new Matrix(nL*3,1);\n\t    var dx = new Matrix(nL*3,1);\n\t    var dt = Math.abs(t[0][0]-t[1][0]);\n\t    for( i=0;i<nL;i++){\n\t        p_init[i][0] = group[i].x;\n\t        p_init[i+nL][0] = 1;\n\t        p_init[i+2*nL][0] = group[i].width;\n\t\n\t        p_min[i][0] = group[i].x-dt;//-group[i].width/4;\n\t        p_min[i+nL][0] = 0;\n\t        p_min[i+2*nL][0] = group[i].width/4;\n\t\n\t        p_max[i][0] = group[i].x+dt;//+group[i].width/4;\n\t        p_max[i+nL][0] = 1.5;\n\t        p_max[i+2*nL][0] = group[i].width*4;\n\t\n\t        dx[i][0] = -dt/1000;\n\t        dx[i+nL][0] = -1e-3;\n\t        dx[i+2*nL][0] = -dt/1000;\n\t    }\n\t\n\t    var dx = -Math.abs(t[0][0]-t[1][0])/10000;\n\t    var p_fit = LM.optimize(sumOfLorentzians, p_init, t, y_data, weight, dx, p_min, p_max, consts, opts);\n\t    p_fit=p_fit.p;\n\t    //Put back the result in the correct format\n\t    var result = new Array(nL);\n\t    for( i=0;i<nL;i++){\n\t        result[i]=[p_fit[i],[p_fit[i+nL][0]*maxY],p_fit[i+2*nL]];\n\t    }\n\t\n\t    return result;\n\t\n\t}\n\t\n\t/**\n\t *\n\t * @param xy A two column matrix containing the x and y data to be fitted\n\t * @param group A set of initial lorentzian parameters to be optimized [center, heigth, half_width_at_half_height]\n\t * @returns {Array} A set of final lorentzian parameters [center, heigth, hwhh*2]\n\t */\n\tfunction optimizeGaussianSum(xy, group, opts){\n\t    var xy2 = parseData(xy);\n\t\n\t    if(xy2===null||xy2[0].rows<3){\n\t        return null; //Cannot run an optimization with less than 3 points\n\t    }\n\t\n\t    var t = xy2[0];\n\t    var y_data = xy2[1];\n\t    var maxY = xy2[2];\n\t    var nbPoints = t.rows,i;\n\t\n\t    var weight = new Matrix(nbPoints,1);//[nbPoints / math.sqrt(y_data.dot(y_data))];\n\t    var k = nbPoints / math.sqrt(y_data.dot(y_data));\n\t    for(i=0;i<nbPoints;i++){\n\t        weight[i][0]=k;///(y_data[i][0]);\n\t        //weight[i][0]=k*(2-y_data[i][0]);\n\t    }\n\t\n\t    var opts=Object.create(opts || [  3,    100, 1e-3, 1e-3, 1e-3, 1e-2, 1e-2,    11,    9,        2 ]);\n\t    //var opts=[  3,    100, 1e-5, 1e-6, 1e-6, 1e-6, 1e-6,    11,    9,        1 ];\n\t    var consts = [ ];// optional vector of constants\n\t\n\t    var nL = group.length;\n\t    var p_init = new Matrix(nL*3,1);\n\t    var p_min =  new Matrix(nL*3,1);\n\t    var p_max =  new Matrix(nL*3,1);\n\t    var dx = new Matrix(nL*3,1);\n\t    var dt = Math.abs(t[0][0]-t[1][0]);\n\t    for( i=0;i<nL;i++){\n\t        p_init[i][0] = group[i].x;\n\t        p_init[i+nL][0] = group[i].y/maxY;\n\t        p_init[i+2*nL][0] = group[i].width;\n\t\n\t        p_min[i][0] = group[i].x-dt;\n\t        p_min[i+nL][0] = group[i].y*0.8/maxY;\n\t        p_min[i+2*nL][0] = group[i].width/2;\n\t\n\t        p_max[i][0] = group[i].x+dt;\n\t        p_max[i+nL][0] = group[i].y*1.2/maxY;\n\t        p_max[i+2*nL][0] = group[i].width*2;\n\t\n\t        dx[i][0] = -dt/1000;\n\t        dx[i+nL][0] = -1e-3;\n\t        dx[i+2*nL][0] = -dt/1000;\n\t    }\n\t    //console.log(t);\n\t    var p_fit = LM.optimize(sumOfLorentzians,p_init,t,y_data,weight,dx,p_min,p_max,consts,opts);\n\t    p_fit = p_fit.p;\n\t    //Put back the result in the correct format\n\t    var result = new Array(nL);\n\t    for( i=0;i<nL;i++){\n\t        result[i]=[p_fit[i],[p_fit[i+nL][0]*maxY],p_fit[i+2*nL]];\n\t    }\n\t\n\t    return result;\n\t\n\t}\n\t/**\n\t *\n\t * Converts the given input to the required x, y column matrices. y data is normalized to max(y)=1\n\t * @param xy\n\t * @returns {*[]}\n\t */\n\tfunction parseData(xy, threshold){\n\t    var nbSeries = xy.length;\n\t    var t = null;\n\t    var y_data = null, x,y;\n\t    var maxY = 0, i,j;\n\t\n\t    if(nbSeries==2){\n\t        //Looks like row wise matrix [x,y]\n\t        var nbPoints = xy[0].length;\n\t        //if(nbPoints<3)\n\t        //    throw new Exception(nbPoints);\n\t        //else{\n\t        t = new Array(nbPoints);//new Matrix(nbPoints,1);\n\t        y_data = new Array(nbPoints);//new Matrix(nbPoints,1);\n\t        x = xy[0];\n\t        y = xy[1];\n\t        if(typeof x[0] === \"number\"){\n\t            for(i=0;i<nbPoints;i++){\n\t                t[i]=x[i];\n\t                y_data[i]=y[i];\n\t                if(y[i]>maxY)\n\t                    maxY = y[i];\n\t            }\n\t        }\n\t        else{\n\t            //It is a colum matrix\n\t            if(typeof x[0] === \"object\"){\n\t                for(i=0;i<nbPoints;i++){\n\t                    t[i]=x[i][0];\n\t                    y_data[i]=y[i][0];\n\t                    if(y[i][0]>maxY)\n\t                        maxY = y[i][0];\n\t                }\n\t            }\n\t\n\t        }\n\t\n\t        //}\n\t    }\n\t    else{\n\t        //Looks like a column wise matrix [[x],[y]]\n\t        var nbPoints = nbSeries;\n\t        //if(nbPoints<3)\n\t        //    throw new SizeException(nbPoints);\n\t        //else {\n\t        t = new Array(nbPoints);//new Matrix(nbPoints, 1);\n\t        y_data = new Array(nbPoints);//new Matrix(nbPoints, 1);\n\t        for (i = 0; i < nbPoints; i++) {\n\t            t[i] = xy[i][0];\n\t            y_data[i] = xy[i][1];\n\t            if(y_data[i]>maxY)\n\t                maxY = y_data[i];\n\t        }\n\t        //}\n\t    }\n\t    for (i = 0; i < nbPoints; i++) {\n\t        y_data[i]/=maxY;\n\t    }\n\t    if(threshold){\n\t        for (i = nbPoints-1; i >=0; i--) {\n\t            if(y_data[i]<threshold) {\n\t                y_data.splice(i,1);\n\t                t.splice(i,1);\n\t            }\n\t        }\n\t    }\n\t    if(t.length>0)\n\t        return [(new Matrix([t])).transpose(),(new Matrix([y_data])).transpose(),maxY];\n\t    return null;\n\t}\n\t\n\tfunction sizeException(nbPoints) {\n\t    return new RangeError(\"Not enough points to perform the optimization: \"+nbPoints +\"< 3\");\n\t}\n\t\n\tmodule.exports.optimizeSingleLorentzian = optimizeSingleLorentzian;\n\tmodule.exports.optimizeLorentzianSum = optimizeLorentzianSum;\n\tmodule.exports.optimizeSingleGaussian = optimizeSingleGaussian;\n\tmodule.exports.optimizeGaussianSum = optimizeGaussianSum;\n\tmodule.exports.singleGaussian = singleGaussian;\n\tmodule.exports.singleLorentzian = singleLorentzian;\n\tmodule.exports.optimizeGaussianTrain = optimizeGaussianTrain;\n\tmodule.exports.optimizeLorentzianTrain = optimizeLorentzianTrain;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tmodule.exports = __webpack_require__(2);\n\tmodule.exports.Matrix = __webpack_require__(3);\n\tmodule.exports.Matrix.algebra = __webpack_require__(12);\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Created by acastillo on 8/5/15.\n\t */\n\tvar Matrix = __webpack_require__(3);\n\tvar math = __webpack_require__(12);\n\t\n\tvar DEBUG = false;\n\t/** Levenberg Marquardt curve-fitting: minimize sum of weighted squared residuals\n\t ----------  INPUT  VARIABLES  -----------\n\t func   = function of n independent variables, 't', and m parameters, 'p',\n\t returning the simulated model: y_hat = func(t,p,c)\n\t p      = n-vector of initial guess of parameter values\n\t t      = m-vectors or matrix of independent variables (used as arg to func)\n\t y_dat  = m-vectors or matrix of data to be fit by func(t,p)\n\t weight = weighting vector for least squares fit ( weight >= 0 ) ...\n\t inverse of the standard measurement errors\n\t Default:  sqrt(d.o.f. / ( y_dat' * y_dat ))\n\t dp     = fractional increment of 'p' for numerical derivatives\n\t dp(j)>0 central differences calculated\n\t dp(j)<0 one sided 'backwards' differences calculated\n\t dp(j)=0 sets corresponding partials to zero; i.e. holds p(j) fixed\n\t Default:  0.001;\n\t p_min  = n-vector of lower bounds for parameter values\n\t p_max  = n-vector of upper bounds for parameter values\n\t c      = an optional matrix of values passed to func(t,p,c)\n\t opts   = vector of algorithmic parameters\n\t parameter    defaults    meaning\n\t opts(1)  =  prnt            3        >1 intermediate results; >2 plots\n\t opts(2)  =  MaxIter      10*Npar     maximum number of iterations\n\t opts(3)  =  epsilon_1       1e-3     convergence tolerance for gradient\n\t opts(4)  =  epsilon_2       1e-3     convergence tolerance for parameters\n\t opts(5)  =  epsilon_3       1e-3     convergence tolerance for Chi-square\n\t opts(6)  =  epsilon_4       1e-2     determines acceptance of a L-M step\n\t opts(7)  =  lambda_0        1e-2     initial value of L-M paramter\n\t opts(8)  =  lambda_UP_fac   11       factor for increasing lambda\n\t opts(9)  =  lambda_DN_fac    9       factor for decreasing lambda\n\t opts(10) =  Update_Type      1       1: Levenberg-Marquardt lambda update\n\t 2: Quadratic update\n\t 3: Nielsen's lambda update equations\n\t\n\t ----------  OUTPUT  VARIABLES  -----------\n\t p       = least-squares optimal estimate of the parameter values\n\t X2      = Chi squared criteria\n\t sigma_p = asymptotic standard error of the parameters\n\t sigma_y = asymptotic standard error of the curve-fit\n\t corr    = correlation matrix of the parameters\n\t R_sq    = R-squared cofficient of multiple determination\n\t cvg_hst = convergence history\n\t\n\t Henri Gavin, Dept. Civil & Environ. Engineering, Duke Univ. 22 Sep 2013\n\t modified from: http://octave.sourceforge.net/optim/function/leasqr.html\n\t using references by\n\t Press, et al., Numerical Recipes, Cambridge Univ. Press, 1992, Chapter 15.\n\t Sam Roweis       http://www.cs.toronto.edu/~roweis/notes/lm.pdf\n\t Manolis Lourakis http://www.ics.forth.gr/~lourakis/levmar/levmar.pdf\n\t Hans Nielson     http://www2.imm.dtu.dk/~hbn/publ/TR9905.ps\n\t Mathworks        optimization toolbox reference manual\n\t K. Madsen, H.B., Nielsen, and O. Tingleff\n\t http://www2.imm.dtu.dk/pubdb/views/edoc_download.php/3215/pdf/imm3215.pdf\n\t */\n\tvar LM = {\n\t\n\t    optimize: function(func,p,t,y_dat,weight,dp,p_min,p_max,c,opts){\n\t\n\t        var tensor_parameter = 0;\t\t\t// set to 1 of parameter is a tensor\n\t\n\t        var iteration  = 0;\t\t\t// iteration counter\n\t        //func_calls = 0;\t\t\t// running count of function evaluations\n\t\n\t        if((typeof p[0])!=\"object\"){\n\t            for(var i=0;i< p.length;i++){\n\t                p[i]=[p[i]];\n\t            }\n\t\n\t        }\n\t        //p = p(:); y_dat = y_dat(:);\t\t// make column vectors\n\t        var i,k;\n\t        var eps = 2^-52;\n\t        var Npar   = p.length;//length(p); \t\t\t// number of parameters\n\t        var Npnt   = y_dat.length;//length(y_dat);\t\t// number of data points\n\t        var p_old  = Matrix.zeros(Npar,1);\t\t// previous set of parameters\n\t        var y_old  = Matrix.zeros(Npnt,1);\t\t// previous model, y_old = y_hat(t;p_old)\n\t        var X2     = 1e-2/eps;\t\t\t// a really big initial Chi-sq value\n\t        var X2_old = 1e-2/eps;\t\t\t// a really big initial Chi-sq value\n\t        var J =  Matrix.zeros(Npnt,Npar);\n\t\n\t\n\t        if (t.length != y_dat.length) {\n\t            console.log('lm.m error: the length of t must equal the length of y_dat');\n\t\n\t            length_t = t.length;\n\t            length_y_dat = y_dat.length;\n\t            var X2 = 0, corr = 0, sigma_p = 0, sigma_y = 0, R_sq = 0, cvg_hist = 0;\n\t            if (!tensor_parameter) {\n\t                return;\n\t            }\n\t        }\n\t\n\t        weight = weight||Math.sqrt((Npnt-Npar+1)/(math.multiply(math.transpose(y_dat),y_dat)));\n\t        dp = dp || 0.001;\n\t        p_min   = p_min || math.multiply(Math.abs(p),-100);\n\t        p_max   = p_max || math.multiply(Math.abs(p),100);\n\t        c = c || 1;\n\t        // Algorithmic Paramters\n\t        //prnt MaxIter  eps1  eps2  epx3  eps4  lam0  lamUP lamDN UpdateType\n\t        opts = opts ||[  3,10*Npar, 1e-3, 1e-3, 1e-3, 1e-2, 1e-2, 11, 9, 1 ];\n\t\n\t        var prnt          = opts[0];\t// >1 intermediate results; >2 plots\n\t        var MaxIter       = opts[1];\t// maximum number of iterations\n\t        var epsilon_1     = opts[2];\t// convergence tolerance for gradient\n\t        var epsilon_2     = opts[3];\t// convergence tolerance for parameter\n\t        var epsilon_3     = opts[4];\t// convergence tolerance for Chi-square\n\t        var epsilon_4     = opts[5];\t// determines acceptance of a L-M step\n\t        var lambda_0      = opts[6];\t// initial value of damping paramter, lambda\n\t        var lambda_UP_fac = opts[7];\t// factor for increasing lambda\n\t        var lambda_DN_fac = opts[8];\t// factor for decreasing lambda\n\t        var Update_Type   = opts[9];\t// 1: Levenberg-Marquardt lambda update\n\t        // 2: Quadratic update\n\t        // 3: Nielsen's lambda update equations\n\t\n\t        if ( tensor_parameter && prnt == 3 ) prnt = 2;\n\t\n\t\n\t        if(!dp.length || dp.length == 1){\n\t            var dp_array = new Array(Npar);\n\t            for(var i=0;i<Npar;i++)\n\t                dp_array[i]=[dp];\n\t            dp=dp_array;\n\t        }\n\t\n\t        // indices of the parameters to be fit\n\t        var idx   = [];\n\t        for(i=0;i<dp.length;i++){\n\t            if(dp[i][0]!=0){\n\t                idx.push(i);\n\t            }\n\t        }\n\t\n\t        var Nfit = idx.length;\t\t\t// number of parameters to fit\n\t        var stop = false;\t\t\t\t// termination flag\n\t\n\t        var weight_sq = null;\n\t        //console.log(weight);\n\t        if ( !weight.length || weight.length < Npnt )\t{\n\t            // squared weighting vector\n\t            //weight_sq = ( weight(1)*ones(Npnt,1) ).^2;\n\t            //console.log(\"weight[0] \"+typeof weight[0]);\n\t            var tmp = math.multiply(Matrix.ones(Npnt,1),weight[0]);\n\t            weight_sq = math.dotMultiply(tmp,tmp);\n\t        }\n\t        else{\n\t            //weight_sq = (weight(:)).^2;\n\t            weight_sq = math.dotMultiply(weight,weight);\n\t        }\n\t\n\t\n\t        // initialize Jacobian with finite difference calculation\n\t        //console.log(\"J \"+weight_sq);\n\t        var result = this.lm_matx(func,t,p_old,y_old,1,J,p,y_dat,weight_sq,dp,c);\n\t        var JtWJ = result.JtWJ,JtWdy=result.JtWdy,X2=result.Chi_sq,y_hat=result.y_hat,J=result.J;\n\t        //[JtWJ,JtWdy,X2,y_hat,J] = this.lm_matx(func,t,p_old,y_old,1,J,p,y_dat,weight_sq,dp,c);\n\t        //console.log(JtWJ);\n\t\n\t        if ( Math.max(Math.abs(JtWdy)) < epsilon_1 ){\n\t            console.log(' *** Your Initial Guess is Extremely Close to Optimal ***')\n\t            console.log(' *** epsilon_1 = ', epsilon_1);\n\t            stop = true;\n\t        }\n\t\n\t\n\t        switch(Update_Type){\n\t            case 1: // Marquardt: init'l lambda\n\t                lambda  = lambda_0;\n\t                break;\n\t            default:    // Quadratic and Nielsen\n\t                lambda  = lambda_0 * Math.max(math.diag(JtWJ));\n\t                nu=2;\n\t        }\n\t        //console.log(X2);\n\t        X2_old = X2; // previous value of X2\n\t        //console.log(MaxIter+\" \"+Npar);\n\t        //var cvg_hst = Matrix.ones(MaxIter,Npar+3);\t\t// initialize convergence history\n\t        var h = null;\n\t        while ( !stop && iteration <= MaxIter ) {\t\t// --- Main Loop\n\t            iteration = iteration + 1;\n\t            // incremental change in parameters\n\t            switch(Update_Type){\n\t                case 1:\t\t\t\t\t// Marquardt\n\t                    //h = ( JtWJ + lambda * math.diag(math.diag(JtWJ)) ) \\ JtWdy;\n\t                    //h = math.multiply(math.inv(JtWdy),math.add(JtWJ,math.multiply(lambda,math.diag(math.diag(Npar)))));\n\t                    h = math.solve(math.add(JtWJ,math.multiply(math.diag(math.diag(JtWJ)),lambda)),JtWdy);\n\t                    break;\n\t                default:\t\t\t\t\t// Quadratic and Nielsen\n\t                    //h = ( JtWJ + lambda * math.eye(Npar) ) \\ JtWdy;\n\t\n\t                    h = math.solve(math.add(JtWJ,math.multiply( Matrix.eye(Npar),lambda)),JtWdy);\n\t            }\n\t\n\t            /*for(var k=0;k< h.length;k++){\n\t             h[k]=[h[k]];\n\t             }*/\n\t            //console.log(\"h \"+h);\n\t            //h=math.matrix(h);\n\t            //  big = max(abs(h./p)) > 2;\n\t            //this is a big step\n\t            // --- Are parameters [p+h] much better than [p] ?\n\t            var hidx = new Array(idx.length);\n\t            for(k=0;k<idx.length;k++){\n\t                hidx[k]=h[idx[k]];\n\t            }\n\t            var p_try = math.add(p, hidx);// update the [idx] elements\n\t\n\t            for(k=0;k<p_try.length;k++){\n\t                p_try[k][0]=Math.min(Math.max(p_min[k][0],p_try[k][0]),p_max[k][0]);\n\t            }\n\t            // p_try = Math.min(Math.max(p_min,p_try),p_max);           // apply constraints\n\t\n\t            var delta_y = math.subtract(y_dat, func(t,p_try,c));       // residual error using p_try\n\t            //func_calls = func_calls + 1;\n\t            //X2_try = delta_y' * ( delta_y .* weight_sq );  // Chi-squared error criteria\n\t\n\t            var X2_try = math.multiply(math.transpose(delta_y),math.dotMultiply(delta_y,weight_sq));\n\t\n\t            if ( Update_Type == 2 ){  \t\t\t  // Quadratic\n\t                //    One step of quadratic line update in the h direction for minimum X2\n\t                //var alpha =  JtWdy'*h / ( (X2_try - X2)/2 + 2*JtWdy'*h ) ;\n\t                var JtWdy_th = math.multiply(math.transpose(JtWdy),h);\n\t                var alpha =  math.multiply(JtWdy_th,math.inv(math.add(math.multiply(math.subtract(X2_try - X2),1/2)),math.multiply(JtWdy_th,2)));//JtWdy'*h / ( (X2_try - X2)/2 + 2*JtWdy'*h ) ;\n\t\n\t                h = math.multiply(alpha, h);\n\t                for(var k=0;k<idx.length;k++){\n\t                    hidx[k]=h[idx[k]];\n\t                }\n\t\n\t                p_try = math.add(p ,hidx);                     // update only [idx] elements\n\t                p_try = math.min(math.max(p_min,p_try),p_max);          // apply constraints\n\t\n\t                delta_y = math.subtract(y_dat, func(t,p_try,c));      // residual error using p_try\n\t                // func_calls = func_calls + 1;\n\t                //X2_try = delta_y' * ( delta_y .* weight_sq ); // Chi-squared error criteria\n\t                X2_try = math.multiply(math.transpose(delta_y), mat.dotMultiply(delta_y, weight_sq));\n\t            }\n\t\n\t            //rho = (X2 - X2_try) / ( 2*h' * (lambda * h + JtWdy) ); // Nielsen\n\t            var rho = (X2-X2_try)/math.multiply(math.multiply(math.transpose(h),2),math.add(math.multiply(lambda, h),JtWdy));\n\t            //console.log(\"rho \"+rho);\n\t            if ( rho > epsilon_4 ) {\t\t// it IS significantly better\n\t                //console.log(\"Here\");\n\t                dX2 = X2 - X2_old;\n\t                X2_old = X2;\n\t                p_old = p;\n\t                y_old = y_hat;\n\t                p = p_try;\t\t\t// accept p_try\n\t\n\t                result = this.lm_matx(func, t, p_old, y_old, dX2, J, p, y_dat, weight_sq, dp, c);\n\t                JtWJ = result.JtWJ,JtWdy=result.JtWdy,X2=result.Chi_sq,y_hat=result.y_hat,J=result.J;\n\t                // decrease lambda ==> Gauss-Newton method\n\t\n\t                switch (Update_Type) {\n\t                    case 1:\t\t\t\t\t\t\t// Levenberg\n\t                        lambda = Math.max(lambda / lambda_DN_fac, 1.e-7);\n\t                        break;\n\t                    case 2:\t\t\t\t\t\t\t// Quadratic\n\t                        lambda = Math.max(lambda / (1 + alpha), 1.e-7);\n\t                        break;\n\t                    case 3:\t\t\t\t\t\t\t// Nielsen\n\t                        lambda = math.multiply(Math.max(1 / 3, 1 - (2 * rho - 1) ^ 3),lambda);\n\t                        nu = 2;\n\t                        break;\n\t                }\n\t            }\n\t            else {\t\t\t\t\t// it IS NOT better\n\t                X2 = X2_old;\t\t\t// do not accept p_try\n\t                if (iteration%(2 * Npar)==0) {\t// rank-1 update of Jacobian\n\t                    result = this.lm_matx(func, t, p_old, y_old, -1, J, p, y_dat, weight_sq, dp, c);\n\t                    JtWJ = result.JtWJ,JtWdy=result.JtWdy,dX2=result.Chi_sq,y_hat=result.y_hat,J=result.J;\n\t                }\n\t\n\t                // increase lambda  ==> gradient descent method\n\t                switch (Update_Type) {\n\t                    case 1:\t\t\t\t\t\t\t// Levenberg\n\t                        lambda = Math.min(lambda * lambda_UP_fac, 1.e7);\n\t                        break;\n\t                    case 2:\t\t\t\t\t\t\t// Quadratic\n\t                        lambda = lambda + Math.abs((X2_try - X2) / 2 / alpha);\n\t                        break;\n\t                    case 3:\t\t\t\t\t\t// Nielsen\n\t                        lambda = lambda * nu;\n\t                        nu = 2 * nu;\n\t                        break;\n\t                }\n\t            }\n\t        }// --- End of Main Loop\n\t\n\t        // --- convergence achieved, find covariance and confidence intervals\n\t\n\t        // equal weights for paramter error analysis\n\t        weight_sq = math.multiply(math.multiply(math.transpose(delta_y),delta_y), Matrix.ones(Npnt,1));\n\t\n\t        weight_sq.apply(function(i,j){\n\t            weight_sq[i][j] = (Npnt-Nfit+1)/weight_sq[i][j];\n\t        });\n\t        //console.log(weight_sq);\n\t        result = this.lm_matx(func,t,p_old,y_old,-1,J,p,y_dat,weight_sq,dp,c);\n\t        JtWJ = result.JtWJ,JtWdy=result.JtWdy,X2=result.Chi_sq,y_hat=result.y_hat,J=result.J;\n\t\n\t        /*if nargout > 2\t\t\t\t// standard error of parameters\n\t         covar = inv(JtWJ);\n\t         sigma_p = sqrt(diag(covar));\n\t         end\n\t\n\t         if nargout > 3\t\t\t\t// standard error of the fit\n\t         //  sigma_y = sqrt(diag(J * covar * J'));\t// slower version of below\n\t         sigma_y = zeros(Npnt,1);\n\t         for i=1:Npnt\n\t         sigma_y(i) = J(i,:) * covar * J(i,:)';\n\t         end\n\t         sigma_y = sqrt(sigma_y);\n\t         end\n\t\n\t         if nargout > 4\t\t\t\t// parameter correlation matrix\n\t         corr = covar ./ [sigma_p*sigma_p'];\n\t         end\n\t\n\t         if nargout > 5\t\t\t\t// coefficient of multiple determination\n\t         R_sq = corrcoef([y_dat y_hat]);\n\t         R_sq = R_sq(1,2).^2;\n\t         end\n\t\n\t         if nargout > 6\t\t\t\t// convergence history\n\t         cvg_hst = cvg_hst(1:iteration,:);\n\t         end*/\n\t\n\t        // endfunction  # ---------------------------------------------------------- LM\n\t\n\t        return { p:p, X2:X2};\n\t    },\n\t\n\t    lm_FD_J:function(func,t,p,y,dp,c) {\n\t        // J = lm_FD_J(func,t,p,y,{dp},{c})\n\t        //\n\t        // partial derivatives (Jacobian) dy/dp for use with lm.m\n\t        // computed via Finite Differences\n\t        // Requires n or 2n function evaluations, n = number of nonzero values of dp\n\t        // -------- INPUT VARIABLES ---------\n\t        // func = function of independent variables, 't', and parameters, 'p',\n\t        //        returning the simulated model: y_hat = func(t,p,c)\n\t        // t  = m-vector of independent variables (used as arg to func)\n\t        // p  = n-vector of current parameter values\n\t        // y  = func(t,p,c) n-vector initialised by user before each call to lm_FD_J\n\t        // dp = fractional increment of p for numerical derivatives\n\t        //      dp(j)>0 central differences calculated\n\t        //      dp(j)<0 one sided differences calculated\n\t        //      dp(j)=0 sets corresponding partials to zero; i.e. holds p(j) fixed\n\t        //      Default:  0.001;\n\t        // c  = optional vector of constants passed to y_hat = func(t,p,c)\n\t        //---------- OUTPUT VARIABLES -------\n\t        // J  = Jacobian Matrix J(i,j)=dy(i)/dp(j)\ti=1:n; j=1:m\n\t\n\t        //   Henri Gavin, Dept. Civil & Environ. Engineering, Duke Univ. November 2005\n\t        //   modified from: ftp://fly.cnuce.cnr.it/pub/software/octave/leasqr/\n\t        //   Press, et al., Numerical Recipes, Cambridge Univ. Press, 1992, Chapter 15.\n\t\n\t        var m = y.length;\t\t\t// number of data points\n\t        var n = p.length;\t\t\t// number of parameters\n\t\n\t        dp = dp || math.multiply( Matrix.ones(n, 1), 0.001);\n\t\n\t        var ps = p.clone();//JSON.parse(JSON.stringify(p));\n\t        //var ps = $.extend(true, [], p);\n\t        var J = new Matrix(m,n), del =new Array(n);         // initialize Jacobian to Zero\n\t\n\t        for (var j = 0;j < n; j++) {\n\t            //console.log(j+\" \"+dp[j]+\" \"+p[j]+\" \"+ps[j]+\" \"+del[j]);\n\t            del[j] = dp[j]*(1+Math.abs(p[j][0]));  // parameter perturbation\n\t            p[j] = [ps[j][0]+del[j]];\t      // perturb parameter p(j)\n\t            //console.log(j+\" \"+dp[j]+\" \"+p[j]+\" \"+ps[j]+\" \"+del[j]);\n\t\n\t            if (del[j] != 0){\n\t                y1 = func(t, p, c);\n\t                //func_calls = func_calls + 1;\n\t                if (dp[j][0] < 0) {\t\t// backwards difference\n\t                    //J(:,j) = math.dotDivide(math.subtract(y1, y),del[j]);//. / del[j];\n\t                    //console.log(del[j]);\n\t                    //console.log(y);\n\t                    var column = math.dotDivide(math.subtract(y1, y),del[j]);\n\t                    for(var k=0;k< m;k++){\n\t                        J[k][j]=column[k][0];\n\t                    }\n\t                    //console.log(column);\n\t                }\n\t                else{\n\t                    p[j][0] = ps[j][0] - del[j];\n\t                    //J(:,j) = (y1 - feval(func, t, p, c)). / (2. * del[j]);\n\t                    var column = math.dotDivide(math.subtract(y1,func(t,p,c)),2*del[j]);\n\t                    for(var k=0;k< m;k++){\n\t                        J[k][j]=column[k][0];\n\t                    }\n\t\n\t                }\t\t\t// central difference, additional func call\n\t            }\n\t\n\t            p[j] = ps[j];\t\t// restore p(j)\n\t\n\t        }\n\t        //console.log(\"lm_FD_J: \"+ JSON.stringify(J));\n\t        return J;\n\t\n\t    },\n\t\n\t    // endfunction # -------------------------------------------------- LM_FD_J\n\t    lm_Broyden_J: function(p_old,y_old,J,p,y){\n\t        // J = lm_Broyden_J(p_old,y_old,J,p,y)\n\t        // carry out a rank-1 update to the Jacobian matrix using Broyden's equation\n\t        //---------- INPUT VARIABLES -------\n\t        // p_old = previous set of parameters\n\t        // y_old = model evaluation at previous set of parameters, y_hat(t;p_old)\n\t        // J  = current version of the Jacobian matrix\n\t        // p     = current  set of parameters\n\t        // y     = model evaluation at current  set of parameters, y_hat(t;p)\n\t        //---------- OUTPUT VARIABLES -------\n\t        // J = rank-1 update to Jacobian Matrix J(i,j)=dy(i)/dp(j)\ti=1:n; j=1:m\n\t        //console.log(p+\" X \"+ p_old)\n\t        var h  = math.subtract(p, p_old);\n\t\n\t        //console.log(\"hhh \"+h);\n\t        var h_t = math.transpose(h);\n\t        h_t.div(math.multiply(h_t,h));\n\t\n\t        //console.log(h_t);\n\t        //J = J + ( y - y_old - J*h )*h' / (h'*h);\t// Broyden rank-1 update eq'n\n\t        J = math.add(J, math.multiply(math.subtract(y, math.add(y_old,math.multiply(J,h))),h_t));\n\t        return J;\n\t        // endfunction # ---------------------------------------------- LM_Broyden_J\n\t    },\n\t\n\t    lm_matx : function (func,t,p_old,y_old,dX2,J,p,y_dat,weight_sq,dp,c,iteration){\n\t        // [JtWJ,JtWdy,Chi_sq,y_hat,J] = this.lm_matx(func,t,p_old,y_old,dX2,J,p,y_dat,weight_sq,{da},{c})\n\t        //\n\t        // Evaluate the linearized fitting matrix, JtWJ, and vector JtWdy,\n\t        // and calculate the Chi-squared error function, Chi_sq\n\t        // Used by Levenberg-Marquard algorithm, lm.m\n\t        // -------- INPUT VARIABLES ---------\n\t        // func   = function ofpn independent variables, p, and m parameters, p,\n\t        //         returning the simulated model: y_hat = func(t,p,c)\n\t        // t      = m-vectors or matrix of independent variables (used as arg to func)\n\t        // p_old  = n-vector of previous parameter values\n\t        // y_old  = m-vector of previous model ... y_old = y_hat(t;p_old);\n\t        // dX2    = previous change in Chi-squared criteria\n\t        // J   = m-by-n Jacobian of model, y_hat, with respect to parameters, p\n\t        // p      = n-vector of current  parameter values\n\t        // y_dat  = n-vector of data to be fit by func(t,p,c)\n\t        // weight_sq = square of the weighting vector for least squares fit ...\n\t        //\t    inverse of the standard measurement errors\n\t        // dp     = fractional increment of 'p' for numerical derivatives\n\t        //          dp(j)>0 central differences calculated\n\t        //          dp(j)<0 one sided differences calculated\n\t        //          dp(j)=0 sets corresponding partials to zero; i.e. holds p(j) fixed\n\t        //          Default:  0.001;\n\t        // c      = optional vector of constants passed to y_hat = func(t,p,c)\n\t        //---------- OUTPUT VARIABLES -------\n\t        // JtWJ\t = linearized Hessian matrix (inverse of covariance matrix)\n\t        // JtWdy   = linearized fitting vector\n\t        // Chi_sq = Chi-squared criteria: weighted sum of the squared residuals WSSR\n\t        // y_hat  = model evaluated with parameters 'p'\n\t        // J   = m-by-n Jacobian of model, y_hat, with respect to parameters, p\n\t\n\t        //   Henri Gavin, Dept. Civil & Environ. Engineering, Duke Univ. November 2005\n\t        //   modified from: ftp://fly.cnuce.cnr.it/pub/software/octave/leasqr/\n\t        //   Press, et al., Numerical Recipes, Cambridge Univ. Press, 1992, Chapter 15.\n\t\n\t\n\t        var Npnt = y_dat.length;\t\t// number of data points\n\t        var Npar = p.length;\t\t// number of parameters\n\t\n\t        dp = dp || 0.001;\n\t\n\t\n\t        //var JtWJ = new Matrix.zeros(Npar);\n\t        //var JtWdy  = new Matrix.zeros(Npar,1);\n\t\n\t        var y_hat = func(t,p,c);\t// evaluate model using parameters 'p'\n\t        //func_calls = func_calls + 1;\n\t        //console.log(J);\n\t        if ( (iteration%(2*Npar))==0 || dX2 > 0 ) {\n\t            //console.log(\"Par\");\n\t            J = this.lm_FD_J(func, t, p, y_hat, dp, c);\t\t// finite difference\n\t        }\n\t        else{\n\t            //console.log(\"ImPar\");\n\t            J = this.lm_Broyden_J(p_old, y_old, J, p, y_hat); // rank-1 update\n\t        }\n\t        var delta_y = math.subtract(y_dat, y_hat);\t// residual error between model and data\n\t        //console.log(delta_y[0][0]);\n\t        //console.log(delta_y.rows+\" \"+delta_y.columns+\" \"+JSON.stringify(weight_sq));\n\t        //var Chi_sq = delta_y' * ( delta_y .* weight_sq ); \t// Chi-squared error criteria\n\t        var Chi_sq = math.multiply(math.transpose(delta_y),math.dotMultiply(delta_y,weight_sq));\n\t        //JtWJ  = J' * ( J .* ( weight_sq * ones(1,Npar) ) );\n\t        var Jt = math.transpose(J);\n\t\n\t        //console.log(weight_sq);\n\t\n\t        var JtWJ = math.multiply(Jt, math.dotMultiply(J,math.multiply(weight_sq, Matrix.ones(1,Npar))));\n\t\n\t        //JtWdy = J' * ( weight_sq .* delta_y );\n\t        var JtWdy = math.multiply(Jt, math.dotMultiply(weight_sq,delta_y));\n\t\n\t\n\t        return {JtWJ:JtWJ,JtWdy:JtWdy,Chi_sq:Chi_sq,y_hat:y_hat,J:J};\n\t        // endfunction  # ------------------------------------------------------ LM_MATX\n\t    }\n\t\n\t\n\t\n\t};\n\t\n\tmodule.exports = LM;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tmodule.exports = __webpack_require__(4);\n\tmodule.exports.Decompositions = module.exports.DC = __webpack_require__(5);\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar Asplice = Array.prototype.splice,\n\t    Aconcat = Array.prototype.concat;\n\t\n\t// For performance : http://jsperf.com/clone-array-slice-vs-while-vs-for\n\tfunction slice(arr) {\n\t    var i = 0,\n\t        ii = arr.length,\n\t        result = new Array(ii);\n\t    for (; i < ii; i++) {\n\t        result[i] = arr[i];\n\t    }\n\t    return result;\n\t}\n\t\n\t/**\n\t * Real matrix.\n\t * @constructor\n\t * @param {number|Array} nRows - Number of rows of the new matrix or a 2D array containing the data.\n\t * @param {number|boolean} [nColumns] - Number of columns of the new matrix or a boolean specifying if the input array should be cloned\n\t */\n\tfunction Matrix(nRows, nColumns) {\n\t    var i = 0, rows, columns, matrix, newInstance;\n\t    if (Array.isArray(nRows)) {\n\t        newInstance = nColumns;\n\t        matrix = newInstance ? slice(nRows) : nRows;\n\t        nRows = matrix.length;\n\t        nColumns = matrix[0].length;\n\t        if (typeof nColumns === 'undefined') {\n\t            throw new TypeError('Data must be a 2D array');\n\t        }\n\t        if (nRows > 0 && nColumns > 0) {\n\t            for (; i < nRows; i++) {\n\t                if (matrix[i].length !== nColumns) {\n\t                    throw new RangeError('Inconsistent array dimensions');\n\t                } else if (newInstance) {\n\t                    matrix[i] = slice(matrix[i]);\n\t                }\n\t            }\n\t        } else {\n\t            throw new RangeError('Invalid dimensions: ' + nRows + 'x' + nColumns);\n\t        }\n\t    } else if (typeof nRows === 'number') { // Create empty matrix\n\t        if (nRows > 0 && nColumns > 0) {\n\t            matrix = new Array(nRows);\n\t            for (; i < nRows; i++) {\n\t                matrix[i] = new Array(nColumns);\n\t            }\n\t        } else {\n\t            throw new RangeError('Invalid dimensions: ' + nRows + 'x' + nColumns);\n\t        }\n\t    } else {\n\t        throw new TypeError('Invalid arguments');\n\t    }\n\t\n\t    Object.defineProperty(matrix, 'rows', {writable: true, value: nRows});\n\t    Object.defineProperty(matrix, 'columns', {writable: true, value: nColumns});\n\t\n\t    matrix.__proto__ = Matrix.prototype;\n\t\n\t    return matrix;\n\t}\n\t\n\t/**\n\t * Constructs a Matrix with the chosen dimensions from a 1D array.\n\t * @param {number} newRows - Number of rows\n\t * @param {number} newColumns - Number of columns\n\t * @param {Array} newData - A 1D array containing data for the matrix\n\t * @returns {Matrix} - The new matrix\n\t */\n\tMatrix.from1DArray = function from1DArray(newRows, newColumns, newData) {\n\t    var length, data, i = 0;\n\t\n\t    length = newRows * newColumns;\n\t    if (length !== newData.length)\n\t        throw new RangeError('Data length does not match given dimensions');\n\t\n\t    data = new Array(newRows);\n\t    for (; i < newRows; i++) {\n\t        data[i] = newData.slice(i * newColumns, (i + 1) * newColumns);\n\t    }\n\t    return new Matrix(data);\n\t};\n\t\n\t/**\n\t * Creates a row vector, a matrix with only one row.\n\t * @param {Array} newData - A 1D array containing data for the vector\n\t * @returns {Matrix} - The new matrix\n\t */\n\tMatrix.rowVector = function rowVector(newData) {\n\t    return new Matrix([newData]);\n\t};\n\t\n\t/**\n\t * Creates a column vector, a matrix with only one column.\n\t * @param {Array} newData - A 1D array containing data for the vector\n\t * @returns {Matrix} - The new matrix\n\t */\n\tMatrix.columnVector = function columnVector(newData) {\n\t    var l = newData.length, vector = new Array(l);\n\t    for (var i = 0; i < l; i++)\n\t        vector[i] = [newData[i]];\n\t    return new Matrix(vector);\n\t};\n\t\n\t/**\n\t * Creates an empty matrix with the given dimensions. Values will be undefined. Same as using new Matrix(rows, columns).\n\t * @param {number} rows - Number of rows\n\t * @param {number} columns - Number of columns\n\t * @returns {Matrix} - The new matrix\n\t */\n\tMatrix.empty = function empty(rows, columns) {\n\t    return new Matrix(rows, columns);\n\t};\n\t\n\t/**\n\t * Creates a matrix with the given dimensions. Values will be set to zero.\n\t * @param {number} rows - Number of rows\n\t * @param {number} columns - Number of columns\n\t * @returns {Matrix} - The new matrix\n\t */\n\tMatrix.zeros = function zeros(rows, columns) {\n\t    return Matrix.empty(rows, columns).fill(0);\n\t};\n\t\n\t/**\n\t * Creates a matrix with the given dimensions. Values will be set to one.\n\t * @param {number} rows - Number of rows\n\t * @param {number} columns - Number of columns\n\t * @returns {Matrix} - The new matrix\n\t */\n\tMatrix.ones = function ones(rows, columns) {\n\t    return Matrix.empty(rows, columns).fill(1);\n\t};\n\t\n\t/**\n\t * Creates a matrix with the given dimensions. Values will be randomly set using Math.random().\n\t * @param {number} rows - Number of rows\n\t * @param {number} columns - Number of columns\n\t * @returns {Matrix} The new matrix\n\t */\n\tMatrix.rand = function rand(rows, columns) {\n\t    var matrix = Matrix.empty(rows, columns);\n\t    for (var i = 0, ii = matrix.rows; i < ii; i++) {\n\t        for (var j = 0, jj = matrix.columns; j < jj; j++) {\n\t            matrix[i][j] = Math.random();\n\t        }\n\t    }\n\t    return matrix;\n\t};\n\t\n\t/**\n\t * Creates an identity matrix with the given dimension. Values of the diagonal will be 1 and other will be 0.\n\t * @param {number} n - Number of rows and columns\n\t * @returns {Matrix} - The new matrix\n\t */\n\tMatrix.eye = function eye(n) {\n\t    var matrix = Matrix.zeros(n, n), l = matrix.rows;\n\t    for (var i = 0; i < l; i++) {\n\t        matrix[i][i] = 1;\n\t    }\n\t    return matrix;\n\t};\n\t\n\t/**\n\t * Creates a diagonal matrix based on the given array.\n\t * @param {Array} data - Array containing the data for the diagonal\n\t * @returns {Matrix} - The new matrix\n\t */\n\tMatrix.diag = function diag(data) {\n\t    var l = data.length, matrix = Matrix.zeros(l, l);\n\t    for (var i = 0; i < l; i++) {\n\t        matrix[i][i] = data[i];\n\t    }\n\t    return matrix;\n\t};\n\t\n\t/**\n\t * Creates an array of indices between two values\n\t * @param {number} from\n\t * @param {number} to\n\t * @returns {Array}\n\t */\n\tMatrix.indices = function indices(from, to) {\n\t    var vector = new Array(to - from);\n\t    for (var i = 0; i < vector.length; i++)\n\t        vector[i] = from++;\n\t    return vector;\n\t};\n\t\n\t// TODO DOC\n\tMatrix.stack = function stack(arg1) {\n\t    var i, j, k;\n\t    if (Matrix.isMatrix(arg1)) {\n\t        var rows = 0,\n\t            cols = 0;\n\t        for (i = 0; i < arguments.length; i++) {\n\t            rows += arguments[i].rows;\n\t            if (arguments[i].columns > cols)\n\t                cols = arguments[i].columns;\n\t        }\n\t\n\t        var r = Matrix.zeros(rows, cols);\n\t        var c = 0;\n\t        for (i = 0; i < arguments.length; i++) {\n\t            var current = arguments[i];\n\t            for (j = 0; j < current.rows; j++) {\n\t                for (k = 0; k < current.columns; k++)\n\t                    r[c][k] = current[j][k];\n\t                c++;\n\t            }\n\t        }\n\t        return r;\n\t    }\n\t    else if (Array.isArray(arg1)) {\n\t        var matrix = Matrix.empty(arguments.length, arg1.length);\n\t        for (i = 0; i < arguments.length; i++)\n\t            matrix.setRow(i, arguments[i]);\n\t        return matrix;\n\t    }\n\t};\n\t\n\t// TODO DOC\n\tMatrix.expand = function expand(base, count) {\n\t    var expansion = [];\n\t    for (var i = 0; i < count.length; i++)\n\t        for (var j = 0; j < count[i]; j++)\n\t            expansion.push(base[i]);\n\t    return new Matrix(expansion);\n\t};\n\t\n\t/**\n\t * Check that the provided value is a Matrix and tries to instantiate one if not\n\t * @param value - The value to check\n\t * @returns {Matrix}\n\t * @throws {TypeError}\n\t */\n\tMatrix.checkMatrix = function checkMatrix(value) {\n\t    if (!value) {\n\t        throw new TypeError('Argument has to be a matrix');\n\t    }\n\t    if (value.klass !== 'Matrix') {\n\t        value = new Matrix(value);\n\t    }\n\t    return value;\n\t};\n\t\n\t/**\n\t * Returns true if the argument is a Matrix, false otherwise\n\t * @param value - The value to check\n\t * @returns {boolean}\n\t */\n\tMatrix.isMatrix = function isMatrix(value) {\n\t    return value ? value.klass === 'Matrix' : false;\n\t};\n\t\n\t/**\n\t * @property {string} - The name of this class.\n\t */\n\tObject.defineProperty(Matrix.prototype, 'klass', {\n\t    get: function klass() {\n\t        return 'Matrix';\n\t    }\n\t});\n\t\n\t/**\n\t * @property {number} - The number of elements in the matrix.\n\t */\n\tObject.defineProperty(Matrix.prototype, 'size', {\n\t    get: function size() {\n\t        return this.rows * this.columns;\n\t    }\n\t});\n\t\n\t/**\n\t * @private\n\t * Internal check that a row index is not out of bounds\n\t * @param {number} index\n\t */\n\tMatrix.prototype.checkRowIndex = function checkRowIndex(index) {\n\t    if (index < 0 || index > this.rows - 1)\n\t        throw new RangeError('Row index out of range.');\n\t};\n\t\n\t/**\n\t * @private\n\t * Internal check that a column index is not out of bounds\n\t * @param {number} index\n\t */\n\tMatrix.prototype.checkColumnIndex = function checkColumnIndex(index) {\n\t    if (index < 0 || index > this.columns - 1)\n\t        throw new RangeError('Column index out of range.');\n\t};\n\t\n\t/**\n\t * @private\n\t * Internal check that two matrices have the same dimensions\n\t * @param {Matrix} otherMatrix\n\t */\n\tMatrix.prototype.checkDimensions = function checkDimensions(otherMatrix) {\n\t    if ((this.rows !== otherMatrix.rows) || (this.columns !== otherMatrix.columns))\n\t        throw new RangeError('Matrices dimensions must be equal.');\n\t};\n\t\n\t/**\n\t * Applies a callback for each element of the matrix. The function is called in the matrix (this) context.\n\t * @param {function} callback - Function that will be called with two parameters : i (row) and j (column)\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.apply = function apply(callback) {\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            callback.call(this, i, j);\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Creates an exact and independent copy of the matrix\n\t * @returns {Matrix}\n\t */\n\tMatrix.prototype.clone = function clone() {\n\t    return new Matrix(this.to2DArray());\n\t};\n\t\n\t/**\n\t * Returns a new 1D array filled row by row with the matrix values\n\t * @returns {Array}\n\t */\n\tMatrix.prototype.to1DArray = function to1DArray() {\n\t    return Aconcat.apply([], this);\n\t};\n\t\n\t/**\n\t * Returns a 2D array containing a copy of the data\n\t * @returns {Array}\n\t */\n\tMatrix.prototype.to2DArray = function to2DArray() {\n\t    var l = this.rows, copy = new Array(l);\n\t    for (var i = 0; i < l; i++) {\n\t        copy[i] = slice(this[i]);\n\t    }\n\t    return copy;\n\t};\n\t\n\t/**\n\t * @returns {boolean} true if the matrix has one row\n\t */\n\tMatrix.prototype.isRowVector = function isRowVector() {\n\t    return this.rows === 1;\n\t};\n\t\n\t/**\n\t * @returns {boolean} true if the matrix has one column\n\t */\n\tMatrix.prototype.isColumnVector = function isColumnVector() {\n\t    return this.columns === 1;\n\t};\n\t\n\t/**\n\t * @returns {boolean} true if the matrix has one row or one column\n\t */\n\tMatrix.prototype.isVector = function isVector() {\n\t    return (this.rows === 1) || (this.columns === 1);\n\t};\n\t\n\t/**\n\t * @returns {boolean} true if the matrix has the same number of rows and columns\n\t */\n\tMatrix.prototype.isSquare = function isSquare() {\n\t    return this.rows === this.columns;\n\t};\n\t\n\t/**\n\t * @returns {boolean} true if the matrix is square and has the same values on both sides of the diagonal\n\t */\n\tMatrix.prototype.isSymmetric = function isSymmetric() {\n\t    if (this.isSquare()) {\n\t        var l = this.rows;\n\t        for (var i = 0; i < l; i++) {\n\t            for (var j = 0; j <= i; j++) {\n\t                if (this[i][j] !== this[j][i]) {\n\t                    return false;\n\t                }\n\t            }\n\t        }\n\t        return true;\n\t    }\n\t    return false;\n\t};\n\t\n\t/**\n\t * Sets a given element of the matrix. mat.set(3,4,1) is equivalent to mat[3][4]=1\n\t * @param {number} rowIndex - Index of the row\n\t * @param {number} columnIndex - Index of the column\n\t * @param {number} value - The new value for the element\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.set = function set(rowIndex, columnIndex, value) {\n\t    this[rowIndex][columnIndex] = value;\n\t    return this;\n\t};\n\t\n\t/**\n\t * Returns the given element of the matrix. mat.get(3,4) is equivalent to matrix[3][4]\n\t * @param {number} rowIndex - Index of the row\n\t * @param {number} columnIndex - Index of the column\n\t * @returns {number}\n\t */\n\tMatrix.prototype.get = function get(rowIndex, columnIndex) {\n\t    return this[rowIndex][columnIndex];\n\t};\n\t\n\t/**\n\t * Fills the matrix with a given value. All elements will be set to this value.\n\t * @param {number} value - New value\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.fill = function fill(value) {\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] = value;\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Negates the matrix. All elements will be multiplied by (-1)\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.neg = function neg() {\n\t    return this.mulS(-1);\n\t};\n\t\n\t/**\n\t * Adds a scalar or values from another matrix (in place)\n\t * @param {number|Matrix} value\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.add = function add(value) {\n\t    if (typeof value === 'number')\n\t        return this.addS(value);\n\t    value = Matrix.checkMatrix(value);\n\t        return this.addM(value);\n\t};\n\t\n\t/**\n\t * Adds a scalar to each element of the matrix\n\t * @param {number} value\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.addS = function addS(value) {\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] += value;\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Adds the value of each element of matrix to the corresponding element of this\n\t * @param {Matrix} matrix\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.addM = function addM(matrix) {\n\t    this.checkDimensions(matrix);\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] += matrix[i][j];\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Subtracts a scalar or values from another matrix (in place)\n\t * @param {number|Matrix} value\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.sub = function sub(value) {\n\t    if (typeof value === 'number')\n\t        return this.subS(value);\n\t    value = Matrix.checkMatrix(value);\n\t        return this.subM(value);\n\t};\n\t\n\t/**\n\t * Subtracts a scalar from each element of the matrix\n\t * @param {number} value\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.subS = function subS(value) {\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] -= value;\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Subtracts the value of each element of matrix from the corresponding element of this\n\t * @param {Matrix} matrix\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.subM = function subM(matrix) {\n\t    this.checkDimensions(matrix);\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] -= matrix[i][j];\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Multiplies a scalar or values from another matrix (in place)\n\t * @param {number|Matrix} value\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.mul = function mul(value) {\n\t    if (typeof value === 'number')\n\t        return this.mulS(value);\n\t    value = Matrix.checkMatrix(value);\n\t        return this.mulM(value);\n\t};\n\t\n\t/**\n\t * Multiplies a scalar with each element of the matrix\n\t * @param {number} value\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.mulS = function mulS(value) {\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] *= value;\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Multiplies the value of each element of matrix with the corresponding element of this\n\t * @param {Matrix} matrix\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.mulM = function mulM(matrix) {\n\t    this.checkDimensions(matrix);\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] *= matrix[i][j];\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Divides by a scalar or values from another matrix (in place)\n\t * @param {number|Matrix} value\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.div = function div(value) {\n\t    if (typeof value === 'number')\n\t        return this.divS(value);\n\t    value = Matrix.checkMatrix(value);\n\t        return this.divM(value);\n\t};\n\t\n\t/**\n\t * Divides each element of the matrix by a scalar\n\t * @param {number} value\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.divS = function divS(value) {\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] /= value;\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Divides each element of this by the corresponding element of matrix\n\t * @param {Matrix} matrix\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.divM = function divM(matrix) {\n\t    this.checkDimensions(matrix);\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] /= matrix[i][j];\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Returns a new array from the given row index\n\t * @param {number} index - Row index\n\t * @returns {Array}\n\t */\n\tMatrix.prototype.getRow = function getRow(index) {\n\t    this.checkRowIndex(index);\n\t    return slice(this[index]);\n\t};\n\t\n\t/**\n\t * Returns a new row vector from the given row index\n\t * @param {number} index - Row index\n\t * @returns {Matrix}\n\t */\n\tMatrix.prototype.getRowVector = function getRowVector(index) {\n\t    return Matrix.rowVector(this.getRow(index));\n\t};\n\t\n\t/**\n\t * Sets a row at the given index\n\t * @param {number} index - Row index\n\t * @param {Array|Matrix} array - Array or vector\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.setRow = function setRow(index, array) {\n\t    this.checkRowIndex(index);\n\t    if (Matrix.isMatrix(array)) array = array.to1DArray();\n\t    if (array.length !== this.columns)\n\t        throw new RangeError('Invalid row size');\n\t    this[index] = slice(array);\n\t    return this;\n\t};\n\t\n\t/**\n\t * Removes a row from the given index\n\t * @param {number} index - Row index\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.removeRow = function removeRow(index) {\n\t    this.checkRowIndex(index);\n\t    if (this.rows === 1)\n\t        throw new RangeError('A matrix cannot have less than one row');\n\t    Asplice.call(this, index, 1);\n\t    this.rows -= 1;\n\t    return this;\n\t};\n\t\n\t/**\n\t * Adds a row at the given index\n\t * @param {number} [index = this.rows] - Row index\n\t * @param {Array|Matrix} array - Array or vector\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.addRow = function addRow(index, array) {\n\t    if (typeof array === 'undefined') {\n\t        array = index;\n\t        index = this.rows;\n\t    }\n\t    if (index < 0 || index > this.rows)\n\t        throw new RangeError('Row index out of range.');\n\t    if (Matrix.isMatrix(array)) array = array.to1DArray();\n\t    if (array.length !== this.columns)\n\t        throw new RangeError('Invalid row size');\n\t    Asplice.call(this, index, 0, slice(array));\n\t    this.rows += 1;\n\t    return this;\n\t};\n\t\n\t/**\n\t * Swaps two rows\n\t * @param {number} row1 - First row index\n\t * @param {number} row2 - Second row index\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.swapRows = function swapRows(row1, row2) {\n\t    this.checkRowIndex(row1);\n\t    this.checkRowIndex(row2);\n\t    var temp = this[row1];\n\t    this[row1] = this[row2];\n\t    this[row2] = temp;\n\t    return this;\n\t};\n\t\n\t/**\n\t * Returns a new array from the given column index\n\t * @param {number} index - Column index\n\t * @returns {Array}\n\t */\n\tMatrix.prototype.getColumn = function getColumn(index) {\n\t    this.checkColumnIndex(index);\n\t    var l = this.rows, column = new Array(l);\n\t    for (var i = 0; i < l; i++) {\n\t        column[i] = this[i][index];\n\t    }\n\t    return column;\n\t};\n\t\n\t/**\n\t * Returns a new column vector from the given column index\n\t * @param {number} index - Column index\n\t * @returns {Matrix}\n\t */\n\tMatrix.prototype.getColumnVector = function getColumnVector(index) {\n\t    return Matrix.columnVector(this.getColumn(index));\n\t};\n\t\n\t/**\n\t * Sets a column at the given index\n\t * @param {number} index - Column index\n\t * @param {Array|Matrix} array - Array or vector\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.setColumn = function setColumn(index, array) {\n\t    this.checkColumnIndex(index);\n\t    if (Matrix.isMatrix(array)) array = array.to1DArray();\n\t    var l = this.rows;\n\t    if (array.length !== l)\n\t        throw new RangeError('Invalid column size');\n\t    for (var i = 0; i < l; i++) {\n\t        this[i][index] = array[i];\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Removes a column from the given index\n\t * @param {number} index - Column index\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.removeColumn = function removeColumn(index) {\n\t    this.checkColumnIndex(index);\n\t    if (this.columns === 1)\n\t        throw new RangeError('A matrix cannot have less than one column');\n\t    for (var i = 0, ii = this.rows; i < ii; i++) {\n\t        this[i].splice(index, 1);\n\t    }\n\t    this.columns -= 1;\n\t    return this;\n\t};\n\t\n\t/**\n\t * Adds a column at the given index\n\t * @param {number} [index = this.columns] - Column index\n\t * @param {Array|Matrix} array - Array or vector\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.addColumn = function addColumn(index, array) {\n\t    if (typeof array === 'undefined') {\n\t        array = index;\n\t        index = this.columns;\n\t    }\n\t    if (index < 0 || index > this.columns)\n\t        throw new RangeError('Column index out of range.');\n\t    if (Matrix.isMatrix(array)) array = array.to1DArray();\n\t    var l = this.rows;\n\t    if (array.length !== l)\n\t        throw new RangeError('Invalid column size');\n\t    for (var i = 0; i < l; i++) {\n\t        this[i].splice(index, 0, array[i]);\n\t    }\n\t    this.columns += 1;\n\t    return this;\n\t};\n\t\n\t/**\n\t * Swaps two columns\n\t * @param {number} column1 - First column index\n\t * @param {number} column2 - Second column index\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.swapColumns = function swapColumns(column1, column2) {\n\t    this.checkRowIndex(column1);\n\t    this.checkRowIndex(column2);\n\t    var l = this.rows, temp, row;\n\t    for (var i = 0; i < l; i++) {\n\t        row = this[i];\n\t        temp = row[column1];\n\t        row[column1] = row[column2];\n\t        row[column2] = temp;\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * @private\n\t * Internal check that the provided vector is an array with the right length\n\t * @param {Array|Matrix} vector\n\t * @returns {Array}\n\t * @throws {RangeError}\n\t */\n\tMatrix.prototype.checkRowVector = function checkRowVector(vector) {\n\t    if (Matrix.isMatrix(vector))\n\t        vector = vector.to1DArray();\n\t    if (vector.length !== this.columns)\n\t        throw new RangeError('vector size must be the same as the number of columns');\n\t    return vector;\n\t};\n\t\n\t/**\n\t * @private\n\t * Internal check that the provided vector is an array with the right length\n\t * @param {Array|Matrix} vector\n\t * @returns {Array}\n\t * @throws {RangeError}\n\t */\n\tMatrix.prototype.checkColumnVector = function checkColumnVector(vector) {\n\t    if (Matrix.isMatrix(vector))\n\t        vector = vector.to1DArray();\n\t    if (vector.length !== this.rows)\n\t        throw new RangeError('vector size must be the same as the number of rows');\n\t    return vector;\n\t};\n\t\n\t/**\n\t * Adds the values of a vector to each row\n\t * @param {Array|Matrix} vector - Array or vector\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.addRowVector = function addRowVector(vector) {\n\t    vector = this.checkRowVector(vector);\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] += vector[j];\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Subtracts the values of a vector from each row\n\t * @param {Array|Matrix} vector - Array or vector\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.subRowVector = function subRowVector(vector) {\n\t    vector = this.checkRowVector(vector);\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] -= vector[j];\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Multiplies the values of a vector with each row\n\t * @param {Array|Matrix} vector - Array or vector\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.mulRowVector = function mulRowVector(vector) {\n\t    vector = this.checkRowVector(vector);\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] *= vector[j];\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Divides the values of each row by those of a vector\n\t * @param {Array|Matrix} vector - Array or vector\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.divRowVector = function divRowVector(vector) {\n\t    vector = this.checkRowVector(vector);\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] /= vector[j];\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Adds the values of a vector to each column\n\t * @param {Array|Matrix} vector - Array or vector\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.addColumnVector = function addColumnVector(vector) {\n\t    vector = this.checkColumnVector(vector);\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] += vector[i];\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Subtracts the values of a vector from each column\n\t * @param {Array|Matrix} vector - Array or vector\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.subColumnVector = function subColumnVector(vector) {\n\t    vector = this.checkColumnVector(vector);\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] -= vector[i];\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Multiplies the values of a vector with each column\n\t * @param {Array|Matrix} vector - Array or vector\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.mulColumnVector = function mulColumnVector(vector) {\n\t    vector = this.checkColumnVector(vector);\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] *= vector[i];\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Divides the values of each column by those of a vector\n\t * @param {Array|Matrix} vector - Array or vector\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.divColumnVector = function divColumnVector(vector) {\n\t    vector = this.checkColumnVector(vector);\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] /= vector[i];\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Multiplies the values of a row with a scalar\n\t * @param {number} index - Row index\n\t * @param {number} value\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.mulRow = function mulRow(index, value) {\n\t    this.checkRowIndex(index);\n\t    var i = 0, l = this.columns;\n\t    for (; i < l; i++) {\n\t        this[index][i] *= value;\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Multiplies the values of a column with a scalar\n\t * @param {number} index - Column index\n\t * @param {number} value\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.mulColumn = function mulColumn(index, value) {\n\t    this.checkColumnIndex(index);\n\t    var i = 0, l = this.rows;\n\t    for (; i < l; i++) {\n\t        this[i][index] *= value;\n\t    }\n\t};\n\t\n\t/**\n\t * A matrix index\n\t * @typedef {Object} MatrixIndex\n\t * @property {number} row\n\t * @property {number} column\n\t */\n\t\n\t/**\n\t * Returns the maximum value of the matrix\n\t * @returns {number}\n\t */\n\tMatrix.prototype.max = function max() {\n\t    var v = -Infinity;\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            if (this[i][j] > v) {\n\t                v = this[i][j];\n\t            }\n\t        }\n\t    }\n\t    return v;\n\t};\n\t\n\t/**\n\t * Returns the index of the maximum value\n\t * @returns {MatrixIndex}\n\t */\n\tMatrix.prototype.maxIndex = function maxIndex() {\n\t    var v = -Infinity;\n\t    var idx = {};\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            if (this[i][j] > v) {\n\t                v = this[i][j];\n\t                idx.row = i;\n\t                idx.column = j;\n\t            }\n\t        }\n\t    }\n\t    return idx;\n\t};\n\t\n\t/**\n\t * Returns the minimum value of the matrix\n\t * @returns {number}\n\t */\n\tMatrix.prototype.min = function min() {\n\t    var v = Infinity;\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            if (this[i][j] < v) {\n\t                v = this[i][j];\n\t            }\n\t        }\n\t    }\n\t    return v;\n\t};\n\t\n\t/**\n\t * Returns the index of the minimum value\n\t * @returns {MatrixIndex}\n\t */\n\tMatrix.prototype.minIndex = function minIndex() {\n\t    var v = Infinity;\n\t    var idx = {};\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            if (this[i][j] < v) {\n\t                v = this[i][j];\n\t                idx.row = i;\n\t                idx.column = j;\n\t            }\n\t        }\n\t    }\n\t    return idx;\n\t};\n\t\n\t/**\n\t * Returns the maximum value of one row\n\t * @param {number} index - Row index\n\t * @returns {number}\n\t */\n\tMatrix.prototype.maxRow = function maxRow(index) {\n\t    this.checkRowIndex(index);\n\t    var v = -Infinity;\n\t    for (var i = 0, ii = this.columns; i < ii; i++) {\n\t        if (this[index][i] > v) {\n\t            v = this[index][i];\n\t        }\n\t    }\n\t    return v;\n\t};\n\t\n\t/**\n\t * Returns the index of the maximum value of one row\n\t * @param {number} index - Row index\n\t * @returns {MatrixIndex}\n\t */\n\tMatrix.prototype.maxRowIndex = function maxRowIndex(index) {\n\t    this.checkRowIndex(index);\n\t    var v = -Infinity;\n\t    var idx = {\n\t            row: index\n\t        };\n\t    for (var i = 0, ii = this.columns; i < ii; i++) {\n\t        if (this[index][i] > v) {\n\t            v = this[index][i];\n\t            idx.column = i;\n\t        }\n\t    }\n\t    return idx;\n\t};\n\t\n\t/**\n\t * Returns the minimum value of one row\n\t * @param {number} index - Row index\n\t * @returns {number}\n\t */\n\tMatrix.prototype.minRow = function minRow(index) {\n\t    this.checkRowIndex(index);\n\t    var v = Infinity;\n\t    for (var i = 0, ii = this.columns; i < ii; i++) {\n\t        if (this[index][i] < v) {\n\t            v = this[index][i];\n\t        }\n\t    }\n\t    return v;\n\t};\n\t\n\t/**\n\t * Returns the index of the maximum value of one row\n\t * @param {number} index - Row index\n\t * @returns {MatrixIndex}\n\t */\n\tMatrix.prototype.minRowIndex = function minRowIndex(index) {\n\t    this.checkRowIndex(index);\n\t    var v = Infinity;\n\t    var idx = {\n\t        row: index,\n\t        column: 0\n\t    };\n\t    for (var i = 0, ii = this.columns; i < ii; i++) {\n\t        if (this[index][i] < v) {\n\t            v = this[index][i];\n\t            idx.column = i;\n\t        }\n\t    }\n\t    return idx;\n\t};\n\t\n\t/**\n\t * Returns the maximum value of one column\n\t * @param {number} index - Column index\n\t * @returns {number}\n\t */\n\tMatrix.prototype.maxColumn = function maxColumn(index) {\n\t    this.checkColumnIndex(index);\n\t    var v = -Infinity;\n\t    for (var i = 0, ii = this.rows; i < ii; i++) {\n\t        if (this[i][index] > v) {\n\t            v = this[i][index];\n\t        }\n\t    }\n\t    return v;\n\t};\n\t\n\t/**\n\t * Returns the index of the maximum value of one column\n\t * @param {number} index - Column index\n\t * @returns {MatrixIndex}\n\t */\n\tMatrix.prototype.maxColumnIndex = function maxColumnIndex(index) {\n\t    this.checkColumnIndex(index);\n\t    var v = -Infinity;\n\t    var idx = {\n\t        row: 0,\n\t        column: index\n\t    };\n\t    for (var i = 0, ii = this.rows; i < ii; i++) {\n\t        if (this[i][index] > v) {\n\t            v = this[i][index];\n\t            idx.row = i;\n\t        }\n\t    }\n\t    return idx;\n\t};\n\t\n\t/**\n\t * Returns the minimum value of one column\n\t * @param {number} index - Column index\n\t * @returns {number}\n\t */\n\tMatrix.prototype.minColumn = function minColumn(index) {\n\t    this.checkColumnIndex(index);\n\t    var v = Infinity;\n\t    for (var i = 0, ii = this.rows; i < ii; i++) {\n\t        if (this[i][index] < v) {\n\t            v = this[i][index];\n\t        }\n\t    }\n\t    return v;\n\t};\n\t\n\t/**\n\t * Returns the index of the minimum value of one column\n\t * @param {number} index - Column index\n\t * @returns {MatrixIndex}\n\t */\n\tMatrix.prototype.minColumnIndex = function minColumnIndex(index) {\n\t    this.checkColumnIndex(index);\n\t    var v = Infinity;\n\t    var idx = {\n\t        row: 0,\n\t        column: index\n\t    };\n\t    for (var i = 0, ii = this.rows; i < ii; i++) {\n\t        if (this[i][index] < v) {\n\t            v = this[i][index];\n\t            idx.row = i;\n\t        }\n\t    }\n\t    return idx;\n\t};\n\t\n\t/**\n\t * Returns an array containing the diagonal values of the matrix\n\t * @returns {Array}\n\t */\n\tMatrix.prototype.diag = function diag() {\n\t    if (!this.isSquare())\n\t        throw new TypeError('Only square matrices have a diagonal.');\n\t    var diag = new Array(this.rows);\n\t    for (var i = 0, ii = this.rows; i < ii; i++) {\n\t        diag[i] = this[i][i];\n\t    }\n\t    return diag;\n\t};\n\t\n\t/**\n\t * Returns the sum of all elements of the matrix\n\t * @returns {number}\n\t */\n\tMatrix.prototype.sum = function sum() {\n\t    var v = 0;\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            v += this[i][j];\n\t        }\n\t    }\n\t    return v;\n\t};\n\t\n\t/**\n\t * Returns the mean of all elements of the matrix\n\t * @returns {number}\n\t */\n\tMatrix.prototype.mean = function mean() {\n\t    return this.sum() / this.size;\n\t};\n\t\n\t/**\n\t * Returns the product of all elements of the matrix\n\t * @returns {number}\n\t */\n\tMatrix.prototype.prod = function prod() {\n\t    var prod = 1;\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            prod *= this[i][j];\n\t        }\n\t    }\n\t    return prod;\n\t};\n\t\n\t/**\n\t * Computes the cumulative sum of the matrix elements (in place, row by row)\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.cumulativeSum = function cumulativeSum() {\n\t    var sum = 0;\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            sum += this[i][j];\n\t            this[i][j] = sum;\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Computes the dot (scalar) product between the matrix and another\n\t * @param {Matrix} other vector\n\t * @returns {number}\n\t */\n\tMatrix.prototype.dot = function dot(other) {\n\t    if (this.size !== other.size)\n\t        throw new RangeError('vectors do not have the same size');\n\t    var vector1 = this.to1DArray();\n\t    var vector2 = other.to1DArray();\n\t    var dot = 0, l = vector1.length;\n\t    for (var i = 0; i < l; i++) {\n\t        dot += vector1[i] * vector2[i];\n\t    }\n\t    return dot;\n\t};\n\t\n\t/**\n\t * Returns the matrix product between this and other\n\t * @returns {Matrix}\n\t */\n\tMatrix.prototype.mmul = function mmul(other) {\n\t    if (!Matrix.isMatrix(other))\n\t        throw new TypeError('parameter \"other\" must be a matrix');\n\t    if (this.columns !== other.rows)\n\t        console.warn('Number of columns of left matrix are not equal to number of rows of right matrix.');\n\t\n\t    var m = this.rows, n = this.columns, p = other.columns;\n\t    var result = new Matrix(m, p);\n\t\n\t    var Bcolj = new Array(n);\n\t    var i, j, k;\n\t    for (j = 0; j < p; j++) {\n\t        for (k = 0; k < n; k++)\n\t            Bcolj[k] = other[k][j];\n\t\n\t        for (i = 0; i < m; i++) {\n\t            var Arowi = this[i];\n\t\n\t            var s = 0;\n\t            for (k = 0; k < n; k++)\n\t                s += Arowi[k] * Bcolj[k];\n\t\n\t            result[i][j] = s;\n\t        }\n\t    }\n\t    return result;\n\t};\n\t\n\t/**\n\t * Sorts the rows (in place)\n\t * @param {function} compareFunction - usual Array.prototype.sort comparison function\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.sortRows = function sortRows(compareFunction) {\n\t    for (var i = 0, ii = this.rows; i < ii; i++) {\n\t        this[i].sort(compareFunction);\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Sorts the columns (in place)\n\t * @param {function} compareFunction - usual Array.prototype.sort comparison function\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.sortColumns = function sortColumns(compareFunction) {\n\t    for (var i = 0, ii = this.columns; i < ii; i++) {\n\t        this.setColumn(i, this.getColumn(i).sort(compareFunction));\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Transposes the matrix and returns a new one containing the result\n\t * @returns {Matrix}\n\t */\n\tMatrix.prototype.transpose = function transpose() {\n\t    var result = new Matrix(this.columns, this.rows);\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            result[j][i] = this[i][j];\n\t        }\n\t    }\n\t    return result;\n\t};\n\t\n\t/**\n\t * Returns a subset of the matrix\n\t * @param {number} startRow - First row index\n\t * @param {number} endRow - Last row index\n\t * @param {number} startColumn - First column index\n\t * @param {number} endColumn - Last column index\n\t * @returns {Matrix}\n\t */\n\tMatrix.prototype.subMatrix = function subMatrix(startRow, endRow, startColumn, endColumn) {\n\t    if ((startRow > endRow) || (startColumn > endColumn) || (startRow < 0) || (startRow >= this.rows) || (endRow < 0) || (endRow >= this.rows) || (startColumn < 0) || (startColumn >= this.columns) || (endColumn < 0) || (endColumn >= this.columns))\n\t        throw new RangeError('Argument out of range');\n\t    var newMatrix = new Matrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\t    for (var i = startRow; i <= endRow; i++) {\n\t        for (var j = startColumn; j <= endColumn; j++) {\n\t            newMatrix[i - startRow][j - startColumn] = this[i][j];\n\t        }\n\t    }\n\t    return newMatrix;\n\t};\n\t\n\t/**\n\t * Returns a subset of the matrix based on an array of row indices\n\t * @param {Array} indices - Array containing the row indices\n\t * @param {number} [startColumn = 0] - First column index\n\t * @param {number} [endColumn = this.columns-1] - Last column index\n\t * @returns {Matrix}\n\t */\n\tMatrix.prototype.subMatrixRow = function subMatrixRow(indices, startColumn, endColumn) {\n\t    if (typeof startColumn === 'undefined') {\n\t        startColumn = 0;\n\t        endColumn = this.columns - 1;\n\t    } else if (typeof endColumn === 'undefined') {\n\t        endColumn = this.columns - 1;\n\t    }\n\t    if ((startColumn > endColumn) || (startColumn < 0) || (startColumn >= this.columns) || (endColumn < 0) || (endColumn >= this.columns))\n\t        throw new RangeError('Argument out of range.');\n\t    var l = indices.length, rows = this.rows,\n\t        X = new Matrix(l, endColumn - startColumn + 1);\n\t    for (var i = 0; i < l; i++) {\n\t        for (var j = startColumn; j <= endColumn; j++) {\n\t            if ((indices[i] < 0) || (indices[i] >= rows))\n\t                throw new RangeError('Argument out of range.');\n\t            X[i][j - startColumn] = this[indices[i]][j];\n\t        }\n\t    }\n\t    return X;\n\t};\n\t\n\t/**\n\t * Returns a subset of the matrix based on an array of column indices\n\t * @param {Array} indices - Array containing the column indices\n\t * @param {number} [startRow = 0] - First row index\n\t * @param {number} [endRow = this.rows-1] - Last row index\n\t * @returns {Matrix}\n\t */\n\tMatrix.prototype.subMatrixColumn = function subMatrixColumn(indices, startRow, endRow) {\n\t    if (typeof startRow === 'undefined') {\n\t        startRow = 0;\n\t        endRow = this.rows - 1;\n\t    } else if (typeof endRow === 'undefined') {\n\t        endRow = this.rows - 1;\n\t    }\n\t    if ((startRow > endRow) || (startRow < 0) || (startRow >= this.rows) || (endRow < 0) || (endRow >= this.rows))\n\t        throw new RangeError('Argument out of range.');\n\t    var l = indices.length, columns = this.columns,\n\t        X = new Matrix(endRow - startRow + 1, l);\n\t    for (var i = 0; i < l; i++) {\n\t        for (var j = startRow; j <= endRow; j++) {\n\t            if ((indices[i] < 0) || (indices[i] >= columns))\n\t                throw new RangeError('Argument out of range.');\n\t            X[j - startRow][i] = this[j][indices[i]];\n\t        }\n\t    }\n\t    return X;\n\t};\n\t\n\t/**\n\t * Returns the trace of the matrix (sum of the diagonal elements)\n\t * @returns {number}\n\t */\n\tMatrix.prototype.trace = function trace() {\n\t    if (!this.isSquare())\n\t        throw new TypeError('The matrix is not square');\n\t    var trace = 0, i = 0, l = this.rows;\n\t    for (; i < l; i++) {\n\t        trace += this[i][i];\n\t    }\n\t    return trace;\n\t};\n\t\n\t/**\n\t * Sets each element of the matrix to its absolute value\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.abs = function abs() {\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] = Math.abs(this[i][j]);\n\t        }\n\t    }\n\t};\n\t\n\tmodule.exports = Matrix;\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar Matrix = __webpack_require__(4);\n\t\n\tvar SingularValueDecomposition = __webpack_require__(6);\n\tvar EigenvalueDecomposition = __webpack_require__(8);\n\tvar LuDecomposition = __webpack_require__(9);\n\tvar QrDecomposition = __webpack_require__(10);\n\tvar CholeskyDecomposition = __webpack_require__(11);\n\t\n\tfunction inverse(matrix) {\n\t    return solve(matrix, Matrix.eye(matrix.rows));\n\t}\n\t\n\tMatrix.prototype.inverse = function () {\n\t    return inverse(this);\n\t};\n\t\n\tfunction solve(leftHandSide, rightHandSide) {\n\t    return leftHandSide.isSquare() ? new LuDecomposition(leftHandSide).solve(rightHandSide) : new QrDecomposition(leftHandSide).solve(rightHandSide);\n\t}\n\t\n\tMatrix.prototype.solve = function (other) {\n\t    return solve(this, other);\n\t};\n\t\n\tmodule.exports = {\n\t    SingularValueDecomposition: SingularValueDecomposition,\n\t    SVD: SingularValueDecomposition,\n\t    EigenvalueDecomposition: EigenvalueDecomposition,\n\t    EVD: EigenvalueDecomposition,\n\t    LuDecomposition: LuDecomposition,\n\t    LU: LuDecomposition,\n\t    QrDecomposition: QrDecomposition,\n\t    QR: QrDecomposition,\n\t    CholeskyDecomposition: CholeskyDecomposition,\n\t    CHO: CholeskyDecomposition,\n\t    inverse: inverse,\n\t    solve: solve\n\t};\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar Matrix = __webpack_require__(4);\n\tvar hypotenuse = __webpack_require__(7).hypotenuse;\n\t\n\t// https://github.com/lutzroeder/Mapack/blob/master/Source/SingularValueDecomposition.cs\n\tfunction SingularValueDecomposition(value, options) {\n\t    if (!(this instanceof SingularValueDecomposition)) {\n\t        return new SingularValueDecomposition(value, options);\n\t    }\n\t    value = Matrix.checkMatrix(value);\n\t\n\t    options = options || {};\n\t\n\t    var a = value.clone(),\n\t        m = value.rows,\n\t        n = value.columns,\n\t        nu = Math.min(m, n);\n\t\n\t    var wantu = true, wantv = true;\n\t    if (options.computeLeftSingularVectors === false)\n\t        wantu = false;\n\t    if (options.computeRightSingularVectors === false)\n\t        wantv = false;\n\t    var autoTranspose = options.autoTranspose === true;\n\t\n\t    var swapped = false;\n\t    if (m < n) {\n\t        if (!autoTranspose) {\n\t            console.warn('Computing SVD on a matrix with more columns than rows. Consider enabling autoTranspose');\n\t        } else {\n\t            a = a.transpose();\n\t            m = a.rows;\n\t            n = a.columns;\n\t            swapped = true;\n\t            var aux = wantu;\n\t            wantu = wantv;\n\t            wantv = aux;\n\t        }\n\t    }\n\t\n\t    var s = new Array(Math.min(m + 1, n)),\n\t        U = Matrix.zeros(m, nu),\n\t        V = Matrix.zeros(n, n),\n\t        e = new Array(n),\n\t        work = new Array(m);\n\t\n\t    var nct = Math.min(m - 1, n);\n\t    var nrt = Math.max(0, Math.min(n - 2, m));\n\t\n\t    var i, j, k, p, t, ks, f, cs, sn, max, kase,\n\t        scale, sp, spm1, epm1, sk, ek, b, c, shift, g;\n\t\n\t    for (k = 0, max = Math.max(nct, nrt); k < max; k++) {\n\t        if (k < nct) {\n\t            s[k] = 0;\n\t            for (i = k; i < m; i++) {\n\t                s[k] = hypotenuse(s[k], a[i][k]);\n\t            }\n\t            if (s[k] !== 0) {\n\t                if (a[k][k] < 0) {\n\t                    s[k] = -s[k];\n\t                }\n\t                for (i = k; i < m; i++) {\n\t                    a[i][k] /= s[k];\n\t                }\n\t                a[k][k] += 1;\n\t            }\n\t            s[k] = -s[k];\n\t        }\n\t\n\t        for (j = k + 1; j < n; j++) {\n\t            if ((k < nct) && (s[k] !== 0)) {\n\t                t = 0;\n\t                for (i = k; i < m; i++) {\n\t                    t += a[i][k] * a[i][j];\n\t                }\n\t                t = -t / a[k][k];\n\t                for (i = k; i < m; i++) {\n\t                    a[i][j] += t * a[i][k];\n\t                }\n\t            }\n\t            e[j] = a[k][j];\n\t        }\n\t\n\t        if (wantu && (k < nct)) {\n\t            for (i = k; i < m; i++) {\n\t                U[i][k] = a[i][k];\n\t            }\n\t        }\n\t\n\t        if (k < nrt) {\n\t            e[k] = 0;\n\t            for (i = k + 1; i < n; i++) {\n\t                e[k] = hypotenuse(e[k], e[i]);\n\t            }\n\t            if (e[k] !== 0) {\n\t                if (e[k + 1] < 0)\n\t                    e[k] = -e[k];\n\t                for (i = k + 1; i < n; i++) {\n\t                    e[i] /= e[k];\n\t                }\n\t                e[k + 1] += 1;\n\t            }\n\t            e[k] = -e[k];\n\t            if ((k + 1 < m) && (e[k] !== 0)) {\n\t                for (i = k + 1; i < m; i++) {\n\t                    work[i] = 0;\n\t                }\n\t                for (j = k + 1; j < n; j++) {\n\t                    for (i = k + 1; i < m; i++) {\n\t                        work[i] += e[j] * a[i][j];\n\t                    }\n\t                }\n\t                for (j = k + 1; j < n; j++) {\n\t                    t = -e[j] / e[k + 1];\n\t                    for (i = k + 1; i < m; i++) {\n\t                        a[i][j] += t * work[i];\n\t                    }\n\t                }\n\t            }\n\t            if (wantv) {\n\t                for (i = k + 1; i < n; i++) {\n\t                    V[i][k] = e[i];\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    p = Math.min(n, m + 1);\n\t    if (nct < n) {\n\t        s[nct] = a[nct][nct];\n\t    }\n\t    if (m < p) {\n\t        s[p - 1] = 0;\n\t    }\n\t    if (nrt + 1 < p) {\n\t        e[nrt] = a[nrt][p - 1];\n\t    }\n\t    e[p - 1] = 0;\n\t\n\t    if (wantu) {\n\t        for (j = nct; j < nu; j++) {\n\t            for (i = 0; i < m; i++) {\n\t                U[i][j] = 0;\n\t            }\n\t            U[j][j] = 1;\n\t        }\n\t        for (k = nct - 1; k >= 0; k--) {\n\t            if (s[k] !== 0) {\n\t                for (j = k + 1; j < nu; j++) {\n\t                    t = 0;\n\t                    for (i = k; i < m; i++) {\n\t                        t += U[i][k] * U[i][j];\n\t                    }\n\t                    t = -t / U[k][k];\n\t                    for (i = k; i < m; i++) {\n\t                        U[i][j] += t * U[i][k];\n\t                    }\n\t                }\n\t                for (i = k; i < m; i++) {\n\t                    U[i][k] = -U[i][k];\n\t                }\n\t                U[k][k] = 1 + U[k][k];\n\t                for (i = 0; i < k - 1; i++) {\n\t                    U[i][k] = 0;\n\t                }\n\t            } else {\n\t                for (i = 0; i < m; i++) {\n\t                    U[i][k] = 0;\n\t                }\n\t                U[k][k] = 1;\n\t            }\n\t        }\n\t    }\n\t\n\t    if (wantv) {\n\t        for (k = n - 1; k >= 0; k--) {\n\t            if ((k < nrt) && (e[k] !== 0)) {\n\t                for (j = k + 1; j < n; j++) {\n\t                    t = 0;\n\t                    for (i = k + 1; i < n; i++) {\n\t                        t += V[i][k] * V[i][j];\n\t                    }\n\t                    t = -t / V[k + 1][k];\n\t                    for (i = k + 1; i < n; i++) {\n\t                        V[i][j] += t * V[i][k];\n\t                    }\n\t                }\n\t            }\n\t            for (i = 0; i < n; i++) {\n\t                V[i][k] = 0;\n\t            }\n\t            V[k][k] = 1;\n\t        }\n\t    }\n\t\n\t    var pp = p - 1,\n\t        iter = 0,\n\t        eps = Math.pow(2, -52);\n\t    while (p > 0) {\n\t        for (k = p - 2; k >= -1; k--) {\n\t            if (k === -1) {\n\t                break;\n\t            }\n\t            if (Math.abs(e[k]) <= eps * (Math.abs(s[k]) + Math.abs(s[k + 1]))) {\n\t                e[k] = 0;\n\t                break;\n\t            }\n\t        }\n\t        if (k === p - 2) {\n\t            kase = 4;\n\t        } else {\n\t            for (ks = p - 1; ks >= k; ks--) {\n\t                if (ks === k) {\n\t                    break;\n\t                }\n\t                t = (ks !== p ? Math.abs(e[ks]) : 0) + (ks !== k + 1 ? Math.abs(e[ks - 1]) : 0);\n\t                if (Math.abs(s[ks]) <= eps * t) {\n\t                    s[ks] = 0;\n\t                    break;\n\t                }\n\t            }\n\t            if (ks === k) {\n\t                kase = 3;\n\t            } else if (ks === p - 1) {\n\t                kase = 1;\n\t            } else {\n\t                kase = 2;\n\t                k = ks;\n\t            }\n\t        }\n\t\n\t        k++;\n\t\n\t        switch (kase) {\n\t            case 1: {\n\t                f = e[p - 2];\n\t                e[p - 2] = 0;\n\t                for (j = p - 2; j >= k; j--) {\n\t                    t = hypotenuse(s[j], f);\n\t                    cs = s[j] / t;\n\t                    sn = f / t;\n\t                    s[j] = t;\n\t                    if (j !== k) {\n\t                        f = -sn * e[j - 1];\n\t                        e[j - 1] = cs * e[j - 1];\n\t                    }\n\t                    if (wantv) {\n\t                        for (i = 0; i < n; i++) {\n\t                            t = cs * V[i][j] + sn * V[i][p - 1];\n\t                            V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n\t                            V[i][j] = t;\n\t                        }\n\t                    }\n\t                }\n\t                break;\n\t            }\n\t            case 2 : {\n\t                f = e[k - 1];\n\t                e[k - 1] = 0;\n\t                for (j = k; j < p; j++) {\n\t                    t = hypotenuse(s[j], f);\n\t                    cs = s[j] / t;\n\t                    sn = f / t;\n\t                    s[j] = t;\n\t                    f = -sn * e[j];\n\t                    e[j] = cs * e[j];\n\t                    if (wantu) {\n\t                        for (i = 0; i < m; i++) {\n\t                            t = cs * U[i][j] + sn * U[i][k - 1];\n\t                            U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n\t                            U[i][j] = t;\n\t                        }\n\t                    }\n\t                }\n\t                break;\n\t            }\n\t            case 3 : {\n\t                scale = Math.max(Math.max(Math.max(Math.max(Math.abs(s[p - 1]), Math.abs(s[p - 2])), Math.abs(e[p - 2])), Math.abs(s[k])), Math.abs(e[k]));\n\t                sp = s[p - 1] / scale;\n\t                spm1 = s[p - 2] / scale;\n\t                epm1 = e[p - 2] / scale;\n\t                sk = s[k] / scale;\n\t                ek = e[k] / scale;\n\t                b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2;\n\t                c = (sp * epm1) * (sp * epm1);\n\t                shift = 0;\n\t                if ((b !== 0) || (c !== 0)) {\n\t                    shift = Math.sqrt(b * b + c);\n\t                    if (b < 0) {\n\t                        shift = -shift;\n\t                    }\n\t                    shift = c / (b + shift);\n\t                }\n\t                f = (sk + sp) * (sk - sp) + shift;\n\t                g = sk * ek;\n\t                for (j = k; j < p - 1; j++) {\n\t                    t = hypotenuse(f, g);\n\t                    cs = f / t;\n\t                    sn = g / t;\n\t                    if (j !== k) {\n\t                        e[j - 1] = t;\n\t                    }\n\t                    f = cs * s[j] + sn * e[j];\n\t                    e[j] = cs * e[j] - sn * s[j];\n\t                    g = sn * s[j + 1];\n\t                    s[j + 1] = cs * s[j + 1];\n\t                    if (wantv) {\n\t                        for (i = 0; i < n; i++) {\n\t                            t = cs * V[i][j] + sn * V[i][j + 1];\n\t                            V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n\t                            V[i][j] = t;\n\t                        }\n\t                    }\n\t                    t = hypotenuse(f, g);\n\t                    cs = f / t;\n\t                    sn = g / t;\n\t                    s[j] = t;\n\t                    f = cs * e[j] + sn * s[j + 1];\n\t                    s[j + 1] = -sn * e[j] + cs * s[j + 1];\n\t                    g = sn * e[j + 1];\n\t                    e[j + 1] = cs * e[j + 1];\n\t                    if (wantu && (j < m - 1)) {\n\t                        for (i = 0; i < m; i++) {\n\t                            t = cs * U[i][j] + sn * U[i][j + 1];\n\t                            U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n\t                            U[i][j] = t;\n\t                        }\n\t                    }\n\t                }\n\t                e[p - 2] = f;\n\t                iter = iter + 1;\n\t                break;\n\t            }\n\t            case 4: {\n\t                if (s[k] <= 0) {\n\t                    s[k] = (s[k] < 0 ? -s[k] : 0);\n\t                    if (wantv) {\n\t                        for (i = 0; i <= pp; i++) {\n\t                            V[i][k] = -V[i][k];\n\t                        }\n\t                    }\n\t                }\n\t                while (k < pp) {\n\t                    if (s[k] >= s[k + 1]) {\n\t                        break;\n\t                    }\n\t                    t = s[k];\n\t                    s[k] = s[k + 1];\n\t                    s[k + 1] = t;\n\t                    if (wantv && (k < n - 1)) {\n\t                        for (i = 0; i < n; i++) {\n\t                            t = V[i][k + 1];\n\t                            V[i][k + 1] = V[i][k];\n\t                            V[i][k] = t;\n\t                        }\n\t                    }\n\t                    if (wantu && (k < m - 1)) {\n\t                        for (i = 0; i < m; i++) {\n\t                            t = U[i][k + 1];\n\t                            U[i][k + 1] = U[i][k];\n\t                            U[i][k] = t;\n\t                        }\n\t                    }\n\t                    k++;\n\t                }\n\t                iter = 0;\n\t                p--;\n\t                break;\n\t            }\n\t        }\n\t    }\n\t\n\t    if (swapped) {\n\t        var tmp = V;\n\t        V = U;\n\t        U = tmp;\n\t    }\n\t\n\t    this.m = m;\n\t    this.n = n;\n\t    this.s = s;\n\t    this.U = U;\n\t    this.V = V;\n\t}\n\t\n\tSingularValueDecomposition.prototype = {\n\t    get condition() {\n\t        return this.s[0] / this.s[Math.min(this.m, this.n) - 1];\n\t    },\n\t    get norm2() {\n\t        return this.s[0];\n\t    },\n\t    get rank() {\n\t        var eps = Math.pow(2, -52),\n\t            tol = Math.max(this.m, this.n) * this.s[0] * eps,\n\t            r = 0,\n\t            s = this.s;\n\t        for (var i = 0, ii = s.length; i < ii; i++) {\n\t            if (s[i] > tol) {\n\t                r++;\n\t            }\n\t        }\n\t        return r;\n\t    },\n\t    get diagonal() {\n\t        return this.s;\n\t    },\n\t    // https://github.com/accord-net/framework/blob/development/Sources/Accord.Math/Decompositions/SingularValueDecomposition.cs\n\t    get threshold() {\n\t        return (Math.pow(2, -52) / 2) * Math.max(this.m, this.n) * this.s[0];\n\t    },\n\t    get leftSingularVectors() {\n\t        return this.U;\n\t    },\n\t    get rightSingularVectors() {\n\t        return this.V;\n\t    },\n\t    get diagonalMatrix() {\n\t        return Matrix.diag(this.s);\n\t    },\n\t    solve: function (value) {\n\t\n\t        var Y = value,\n\t            e = this.threshold,\n\t            scols = this.s.length,\n\t            Ls = Matrix.zeros(scols, scols),\n\t            i;\n\t\n\t        for (i = 0; i < scols; i++) {\n\t            if (Math.abs(this.s[i]) <= e) {\n\t                Ls[i][i] = 0;\n\t            } else {\n\t                Ls[i][i] = 1 / this.s[i];\n\t            }\n\t        }\n\t\n\t\n\t        var VL = this.V.mmul(Ls),\n\t            vrows = this.V.rows,\n\t            urows = this.U.rows,\n\t            VLU = Matrix.zeros(vrows, urows),\n\t            j, k, sum;\n\t\n\t        for (i = 0; i < vrows; i++) {\n\t            for (j = 0; j < urows; j++) {\n\t                sum = 0;\n\t                for (k = 0; k < scols; k++) {\n\t                    sum += VL[i][k] * this.U[j][k];\n\t                }\n\t                VLU[i][j] = sum;\n\t            }\n\t        }\n\t\n\t        return VLU.mmul(Y);\n\t    },\n\t    solveForDiagonal: function (value) {\n\t        return this.solve(Matrix.diag(value));\n\t    },\n\t    inverse: function () {\n\t        var e = this.threshold,\n\t            vrows = this.V.rows,\n\t            vcols = this.V.columns,\n\t            X = new Matrix(vrows, this.s.length),\n\t            i, j;\n\t\n\t        for (i = 0; i < vrows; i++) {\n\t            for (j = 0; j < vcols; j++) {\n\t                if (Math.abs(this.s[j]) > e) {\n\t                    X[i][j] = this.V[i][j] / this.s[j];\n\t                } else {\n\t                    X[i][j] = 0;\n\t                }\n\t            }\n\t        }\n\t\n\t        var urows = this.U.rows,\n\t            ucols = this.U.columns,\n\t            Y = new Matrix(vrows, urows),\n\t            k, sum;\n\t\n\t        for (i = 0; i < vrows; i++) {\n\t            for (j = 0; j < urows; j++) {\n\t                sum = 0;\n\t                for (k = 0; k < ucols; k++) {\n\t                    sum += X[i][k] * this.U[j][k];\n\t                }\n\t                Y[i][j] = sum;\n\t            }\n\t        }\n\t\n\t        return Y;\n\t    }\n\t};\n\t\n\tmodule.exports = SingularValueDecomposition;\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\texports.hypotenuse = function hypotenuse(a, b) {\n\t    var r;\n\t    if (Math.abs(a) > Math.abs(b)) {\n\t        r = b / a;\n\t        return Math.abs(a) * Math.sqrt(1 + r * r);\n\t    }\n\t    if (b !== 0) {\n\t        r = a / b;\n\t        return Math.abs(b) * Math.sqrt(1 + r * r);\n\t    }\n\t    return 0;\n\t};\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar Matrix = __webpack_require__(4);\n\tvar hypotenuse = __webpack_require__(7).hypotenuse;\n\t\n\t// https://github.com/lutzroeder/Mapack/blob/master/Source/EigenvalueDecomposition.cs\n\tfunction EigenvalueDecomposition(matrix) {\n\t    if (!(this instanceof EigenvalueDecomposition)) {\n\t        return new EigenvalueDecomposition(matrix);\n\t    }\n\t    matrix = Matrix.checkMatrix(matrix);\n\t    if (!matrix.isSquare()) {\n\t        throw new Error('Matrix is not a square matrix');\n\t    }\n\t\n\t    var n = matrix.columns,\n\t        V = Matrix.zeros(n, n),\n\t        d = new Array(n),\n\t        e = new Array(n),\n\t        value = matrix,\n\t        i, j;\n\t\n\t    if (matrix.isSymmetric()) {\n\t        for (i = 0; i < n; i++) {\n\t            for (j = 0; j < n; j++) {\n\t                V[i][j] = value[i][j];\n\t            }\n\t        }\n\t        tred2(n, e, d, V);\n\t        tql2(n, e, d, V);\n\t    }\n\t    else {\n\t        var H = Matrix.zeros(n, n),\n\t            ort = new Array(n);\n\t        for (j = 0; j < n; j++) {\n\t            for (i = 0; i < n; i++) {\n\t                H[i][j] = value[i][j];\n\t            }\n\t        }\n\t        orthes(n, H, ort, V);\n\t        hqr2(n, e, d, V, H);\n\t    }\n\t\n\t    this.n = n;\n\t    this.e = e;\n\t    this.d = d;\n\t    this.V = V;\n\t}\n\t\n\tEigenvalueDecomposition.prototype = {\n\t    get realEigenvalues() {\n\t        return this.d;\n\t    },\n\t    get imaginaryEigenvalues() {\n\t        return this.e;\n\t    },\n\t    get eigenvectorMatrix() {\n\t        return this.V;\n\t    },\n\t    get diagonalMatrix() {\n\t        var n = this.n,\n\t            e = this.e,\n\t            d = this.d,\n\t            X = new Matrix(n, n),\n\t            i, j;\n\t        for (i = 0; i < n; i++) {\n\t            for (j = 0; j < n; j++) {\n\t                X[i][j] = 0;\n\t            }\n\t            X[i][i] = d[i];\n\t            if (e[i] > 0) {\n\t                X[i][i + 1] = e[i];\n\t            }\n\t            else if (e[i] < 0) {\n\t                X[i][i - 1] = e[i];\n\t            }\n\t        }\n\t        return X;\n\t    }\n\t};\n\t\n\tfunction tred2(n, e, d, V) {\n\t\n\t    var f, g, h, i, j, k,\n\t        hh, scale;\n\t\n\t    for (j = 0; j < n; j++) {\n\t        d[j] = V[n - 1][j];\n\t    }\n\t\n\t    for (i = n - 1; i > 0; i--) {\n\t        scale = 0;\n\t        h = 0;\n\t        for (k = 0; k < i; k++) {\n\t            scale = scale + Math.abs(d[k]);\n\t        }\n\t\n\t        if (scale === 0) {\n\t            e[i] = d[i - 1];\n\t            for (j = 0; j < i; j++) {\n\t                d[j] = V[i - 1][j];\n\t                V[i][j] = 0;\n\t                V[j][i] = 0;\n\t            }\n\t        } else {\n\t            for (k = 0; k < i; k++) {\n\t                d[k] /= scale;\n\t                h += d[k] * d[k];\n\t            }\n\t\n\t            f = d[i - 1];\n\t            g = Math.sqrt(h);\n\t            if (f > 0) {\n\t                g = -g;\n\t            }\n\t\n\t            e[i] = scale * g;\n\t            h = h - f * g;\n\t            d[i - 1] = f - g;\n\t            for (j = 0; j < i; j++) {\n\t                e[j] = 0;\n\t            }\n\t\n\t            for (j = 0; j < i; j++) {\n\t                f = d[j];\n\t                V[j][i] = f;\n\t                g = e[j] + V[j][j] * f;\n\t                for (k = j + 1; k <= i - 1; k++) {\n\t                    g += V[k][j] * d[k];\n\t                    e[k] += V[k][j] * f;\n\t                }\n\t                e[j] = g;\n\t            }\n\t\n\t            f = 0;\n\t            for (j = 0; j < i; j++) {\n\t                e[j] /= h;\n\t                f += e[j] * d[j];\n\t            }\n\t\n\t            hh = f / (h + h);\n\t            for (j = 0; j < i; j++) {\n\t                e[j] -= hh * d[j];\n\t            }\n\t\n\t            for (j = 0; j < i; j++) {\n\t                f = d[j];\n\t                g = e[j];\n\t                for (k = j; k <= i - 1; k++) {\n\t                    V[k][j] -= (f * e[k] + g * d[k]);\n\t                }\n\t                d[j] = V[i - 1][j];\n\t                V[i][j] = 0;\n\t            }\n\t        }\n\t        d[i] = h;\n\t    }\n\t\n\t    for (i = 0; i < n - 1; i++) {\n\t        V[n - 1][i] = V[i][i];\n\t        V[i][i] = 1;\n\t        h = d[i + 1];\n\t        if (h !== 0) {\n\t            for (k = 0; k <= i; k++) {\n\t                d[k] = V[k][i + 1] / h;\n\t            }\n\t\n\t            for (j = 0; j <= i; j++) {\n\t                g = 0;\n\t                for (k = 0; k <= i; k++) {\n\t                    g += V[k][i + 1] * V[k][j];\n\t                }\n\t                for (k = 0; k <= i; k++) {\n\t                    V[k][j] -= g * d[k];\n\t                }\n\t            }\n\t        }\n\t\n\t        for (k = 0; k <= i; k++) {\n\t            V[k][i + 1] = 0;\n\t        }\n\t    }\n\t\n\t    for (j = 0; j < n; j++) {\n\t        d[j] = V[n - 1][j];\n\t        V[n - 1][j] = 0;\n\t    }\n\t\n\t    V[n - 1][n - 1] = 1;\n\t    e[0] = 0;\n\t}\n\t\n\tfunction tql2(n, e, d, V) {\n\t\n\t    var g, h, i, j, k, l, m, p, r,\n\t        dl1, c, c2, c3, el1, s, s2,\n\t        iter;\n\t\n\t    for (i = 1; i < n; i++) {\n\t        e[i - 1] = e[i];\n\t    }\n\t\n\t    e[n - 1] = 0;\n\t\n\t    var f = 0,\n\t        tst1 = 0,\n\t        eps = Math.pow(2, -52);\n\t\n\t    for (l = 0; l < n; l++) {\n\t        tst1 = Math.max(tst1, Math.abs(d[l]) + Math.abs(e[l]));\n\t        m = l;\n\t        while (m < n) {\n\t            if (Math.abs(e[m]) <= eps * tst1) {\n\t                break;\n\t            }\n\t            m++;\n\t        }\n\t\n\t        if (m > l) {\n\t            iter = 0;\n\t            do {\n\t                iter = iter + 1;\n\t\n\t                g = d[l];\n\t                p = (d[l + 1] - g) / (2 * e[l]);\n\t                r = hypotenuse(p, 1);\n\t                if (p < 0) {\n\t                    r = -r;\n\t                }\n\t\n\t                d[l] = e[l] / (p + r);\n\t                d[l + 1] = e[l] * (p + r);\n\t                dl1 = d[l + 1];\n\t                h = g - d[l];\n\t                for (i = l + 2; i < n; i++) {\n\t                    d[i] -= h;\n\t                }\n\t\n\t                f = f + h;\n\t\n\t                p = d[m];\n\t                c = 1;\n\t                c2 = c;\n\t                c3 = c;\n\t                el1 = e[l + 1];\n\t                s = 0;\n\t                s2 = 0;\n\t                for (i = m - 1; i >= l; i--) {\n\t                    c3 = c2;\n\t                    c2 = c;\n\t                    s2 = s;\n\t                    g = c * e[i];\n\t                    h = c * p;\n\t                    r = hypotenuse(p, e[i]);\n\t                    e[i + 1] = s * r;\n\t                    s = e[i] / r;\n\t                    c = p / r;\n\t                    p = c * d[i] - s * g;\n\t                    d[i + 1] = h + s * (c * g + s * d[i]);\n\t\n\t                    for (k = 0; k < n; k++) {\n\t                        h = V[k][i + 1];\n\t                        V[k][i + 1] = s * V[k][i] + c * h;\n\t                        V[k][i] = c * V[k][i] - s * h;\n\t                    }\n\t                }\n\t\n\t                p = -s * s2 * c3 * el1 * e[l] / dl1;\n\t                e[l] = s * p;\n\t                d[l] = c * p;\n\t\n\t            }\n\t            while (Math.abs(e[l]) > eps * tst1);\n\t        }\n\t        d[l] = d[l] + f;\n\t        e[l] = 0;\n\t    }\n\t\n\t    for (i = 0; i < n - 1; i++) {\n\t        k = i;\n\t        p = d[i];\n\t        for (j = i + 1; j < n; j++) {\n\t            if (d[j] < p) {\n\t                k = j;\n\t                p = d[j];\n\t            }\n\t        }\n\t\n\t        if (k !== i) {\n\t            d[k] = d[i];\n\t            d[i] = p;\n\t            for (j = 0; j < n; j++) {\n\t                p = V[j][i];\n\t                V[j][i] = V[j][k];\n\t                V[j][k] = p;\n\t            }\n\t        }\n\t    }\n\t}\n\t\n\tfunction orthes(n, H, ort, V) {\n\t\n\t    var low = 0,\n\t        high = n - 1,\n\t        f, g, h, i, j, m,\n\t        scale;\n\t\n\t    for (m = low + 1; m <= high - 1; m++) {\n\t        scale = 0;\n\t        for (i = m; i <= high; i++) {\n\t            scale = scale + Math.abs(H[i][m - 1]);\n\t        }\n\t\n\t        if (scale !== 0) {\n\t            h = 0;\n\t            for (i = high; i >= m; i--) {\n\t                ort[i] = H[i][m - 1] / scale;\n\t                h += ort[i] * ort[i];\n\t            }\n\t\n\t            g = Math.sqrt(h);\n\t            if (ort[m] > 0) {\n\t                g = -g;\n\t            }\n\t\n\t            h = h - ort[m] * g;\n\t            ort[m] = ort[m] - g;\n\t\n\t            for (j = m; j < n; j++) {\n\t                f = 0;\n\t                for (i = high; i >= m; i--) {\n\t                    f += ort[i] * H[i][j];\n\t                }\n\t\n\t                f = f / h;\n\t                for (i = m; i <= high; i++) {\n\t                    H[i][j] -= f * ort[i];\n\t                }\n\t            }\n\t\n\t            for (i = 0; i <= high; i++) {\n\t                f = 0;\n\t                for (j = high; j >= m; j--) {\n\t                    f += ort[j] * H[i][j];\n\t                }\n\t\n\t                f = f / h;\n\t                for (j = m; j <= high; j++) {\n\t                    H[i][j] -= f * ort[j];\n\t                }\n\t            }\n\t\n\t            ort[m] = scale * ort[m];\n\t            H[m][m - 1] = scale * g;\n\t        }\n\t    }\n\t\n\t    for (i = 0; i < n; i++) {\n\t        for (j = 0; j < n; j++) {\n\t            V[i][j] = (i === j ? 1 : 0);\n\t        }\n\t    }\n\t\n\t    for (m = high - 1; m >= low + 1; m--) {\n\t        if (H[m][m - 1] !== 0) {\n\t            for (i = m + 1; i <= high; i++) {\n\t                ort[i] = H[i][m - 1];\n\t            }\n\t\n\t            for (j = m; j <= high; j++) {\n\t                g = 0;\n\t                for (i = m; i <= high; i++) {\n\t                    g += ort[i] * V[i][j];\n\t                }\n\t\n\t                g = (g / ort[m]) / H[m][m - 1];\n\t                for (i = m; i <= high; i++) {\n\t                    V[i][j] += g * ort[i];\n\t                }\n\t            }\n\t        }\n\t    }\n\t}\n\t\n\tfunction hqr2(nn, e, d, V, H) {\n\t    var n = nn - 1,\n\t        low = 0,\n\t        high = nn - 1,\n\t        eps = Math.pow(2, -52),\n\t        exshift = 0,\n\t        norm = 0,\n\t        p = 0,\n\t        q = 0,\n\t        r = 0,\n\t        s = 0,\n\t        z = 0,\n\t        iter = 0,\n\t        i, j, k, l, m, t, w, x, y,\n\t        ra, sa, vr, vi,\n\t        notlast, cdivres;\n\t\n\t    for (i = 0; i < nn; i++) {\n\t        if (i < low || i > high) {\n\t            d[i] = H[i][i];\n\t            e[i] = 0;\n\t        }\n\t\n\t        for (j = Math.max(i - 1, 0); j < nn; j++) {\n\t            norm = norm + Math.abs(H[i][j]);\n\t        }\n\t    }\n\t\n\t    while (n >= low) {\n\t        l = n;\n\t        while (l > low) {\n\t            s = Math.abs(H[l - 1][l - 1]) + Math.abs(H[l][l]);\n\t            if (s === 0) {\n\t                s = norm;\n\t            }\n\t            if (Math.abs(H[l][l - 1]) < eps * s) {\n\t                break;\n\t            }\n\t            l--;\n\t        }\n\t\n\t        if (l === n) {\n\t            H[n][n] = H[n][n] + exshift;\n\t            d[n] = H[n][n];\n\t            e[n] = 0;\n\t            n--;\n\t            iter = 0;\n\t        } else if (l === n - 1) {\n\t            w = H[n][n - 1] * H[n - 1][n];\n\t            p = (H[n - 1][n - 1] - H[n][n]) / 2;\n\t            q = p * p + w;\n\t            z = Math.sqrt(Math.abs(q));\n\t            H[n][n] = H[n][n] + exshift;\n\t            H[n - 1][n - 1] = H[n - 1][n - 1] + exshift;\n\t            x = H[n][n];\n\t\n\t            if (q >= 0) {\n\t                z = (p >= 0) ? (p + z) : (p - z);\n\t                d[n - 1] = x + z;\n\t                d[n] = d[n - 1];\n\t                if (z !== 0) {\n\t                    d[n] = x - w / z;\n\t                }\n\t                e[n - 1] = 0;\n\t                e[n] = 0;\n\t                x = H[n][n - 1];\n\t                s = Math.abs(x) + Math.abs(z);\n\t                p = x / s;\n\t                q = z / s;\n\t                r = Math.sqrt(p * p + q * q);\n\t                p = p / r;\n\t                q = q / r;\n\t\n\t                for (j = n - 1; j < nn; j++) {\n\t                    z = H[n - 1][j];\n\t                    H[n - 1][j] = q * z + p * H[n][j];\n\t                    H[n][j] = q * H[n][j] - p * z;\n\t                }\n\t\n\t                for (i = 0; i <= n; i++) {\n\t                    z = H[i][n - 1];\n\t                    H[i][n - 1] = q * z + p * H[i][n];\n\t                    H[i][n] = q * H[i][n] - p * z;\n\t                }\n\t\n\t                for (i = low; i <= high; i++) {\n\t                    z = V[i][n - 1];\n\t                    V[i][n - 1] = q * z + p * V[i][n];\n\t                    V[i][n] = q * V[i][n] - p * z;\n\t                }\n\t            } else {\n\t                d[n - 1] = x + p;\n\t                d[n] = x + p;\n\t                e[n - 1] = z;\n\t                e[n] = -z;\n\t            }\n\t\n\t            n = n - 2;\n\t            iter = 0;\n\t        } else {\n\t            x = H[n][n];\n\t            y = 0;\n\t            w = 0;\n\t            if (l < n) {\n\t                y = H[n - 1][n - 1];\n\t                w = H[n][n - 1] * H[n - 1][n];\n\t            }\n\t\n\t            if (iter === 10) {\n\t                exshift += x;\n\t                for (i = low; i <= n; i++) {\n\t                    H[i][i] -= x;\n\t                }\n\t                s = Math.abs(H[n][n - 1]) + Math.abs(H[n - 1][n - 2]);\n\t                x = y = 0.75 * s;\n\t                w = -0.4375 * s * s;\n\t            }\n\t\n\t            if (iter === 30) {\n\t                s = (y - x) / 2;\n\t                s = s * s + w;\n\t                if (s > 0) {\n\t                    s = Math.sqrt(s);\n\t                    if (y < x) {\n\t                        s = -s;\n\t                    }\n\t                    s = x - w / ((y - x) / 2 + s);\n\t                    for (i = low; i <= n; i++) {\n\t                        H[i][i] -= s;\n\t                    }\n\t                    exshift += s;\n\t                    x = y = w = 0.964;\n\t                }\n\t            }\n\t\n\t            iter = iter + 1;\n\t\n\t            m = n - 2;\n\t            while (m >= l) {\n\t                z = H[m][m];\n\t                r = x - z;\n\t                s = y - z;\n\t                p = (r * s - w) / H[m + 1][m] + H[m][m + 1];\n\t                q = H[m + 1][m + 1] - z - r - s;\n\t                r = H[m + 2][m + 1];\n\t                s = Math.abs(p) + Math.abs(q) + Math.abs(r);\n\t                p = p / s;\n\t                q = q / s;\n\t                r = r / s;\n\t                if (m === l) {\n\t                    break;\n\t                }\n\t                if (Math.abs(H[m][m - 1]) * (Math.abs(q) + Math.abs(r)) < eps * (Math.abs(p) * (Math.abs(H[m - 1][m - 1]) + Math.abs(z) + Math.abs(H[m + 1][m + 1])))) {\n\t                    break;\n\t                }\n\t                m--;\n\t            }\n\t\n\t            for (i = m + 2; i <= n; i++) {\n\t                H[i][i - 2] = 0;\n\t                if (i > m + 2) {\n\t                    H[i][i - 3] = 0;\n\t                }\n\t            }\n\t\n\t            for (k = m; k <= n - 1; k++) {\n\t                notlast = (k !== n - 1);\n\t                if (k !== m) {\n\t                    p = H[k][k - 1];\n\t                    q = H[k + 1][k - 1];\n\t                    r = (notlast ? H[k + 2][k - 1] : 0);\n\t                    x = Math.abs(p) + Math.abs(q) + Math.abs(r);\n\t                    if (x !== 0) {\n\t                        p = p / x;\n\t                        q = q / x;\n\t                        r = r / x;\n\t                    }\n\t                }\n\t\n\t                if (x === 0) {\n\t                    break;\n\t                }\n\t\n\t                s = Math.sqrt(p * p + q * q + r * r);\n\t                if (p < 0) {\n\t                    s = -s;\n\t                }\n\t\n\t                if (s !== 0) {\n\t                    if (k !== m) {\n\t                        H[k][k - 1] = -s * x;\n\t                    } else if (l !== m) {\n\t                        H[k][k - 1] = -H[k][k - 1];\n\t                    }\n\t\n\t                    p = p + s;\n\t                    x = p / s;\n\t                    y = q / s;\n\t                    z = r / s;\n\t                    q = q / p;\n\t                    r = r / p;\n\t\n\t                    for (j = k; j < nn; j++) {\n\t                        p = H[k][j] + q * H[k + 1][j];\n\t                        if (notlast) {\n\t                            p = p + r * H[k + 2][j];\n\t                            H[k + 2][j] = H[k + 2][j] - p * z;\n\t                        }\n\t\n\t                        H[k][j] = H[k][j] - p * x;\n\t                        H[k + 1][j] = H[k + 1][j] - p * y;\n\t                    }\n\t\n\t                    for (i = 0; i <= Math.min(n, k + 3); i++) {\n\t                        p = x * H[i][k] + y * H[i][k + 1];\n\t                        if (notlast) {\n\t                            p = p + z * H[i][k + 2];\n\t                            H[i][k + 2] = H[i][k + 2] - p * r;\n\t                        }\n\t\n\t                        H[i][k] = H[i][k] - p;\n\t                        H[i][k + 1] = H[i][k + 1] - p * q;\n\t                    }\n\t\n\t                    for (i = low; i <= high; i++) {\n\t                        p = x * V[i][k] + y * V[i][k + 1];\n\t                        if (notlast) {\n\t                            p = p + z * V[i][k + 2];\n\t                            V[i][k + 2] = V[i][k + 2] - p * r;\n\t                        }\n\t\n\t                        V[i][k] = V[i][k] - p;\n\t                        V[i][k + 1] = V[i][k + 1] - p * q;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    if (norm === 0) {\n\t        return;\n\t    }\n\t\n\t    for (n = nn - 1; n >= 0; n--) {\n\t        p = d[n];\n\t        q = e[n];\n\t\n\t        if (q === 0) {\n\t            l = n;\n\t            H[n][n] = 1;\n\t            for (i = n - 1; i >= 0; i--) {\n\t                w = H[i][i] - p;\n\t                r = 0;\n\t                for (j = l; j <= n; j++) {\n\t                    r = r + H[i][j] * H[j][n];\n\t                }\n\t\n\t                if (e[i] < 0) {\n\t                    z = w;\n\t                    s = r;\n\t                } else {\n\t                    l = i;\n\t                    if (e[i] === 0) {\n\t                        H[i][n] = (w !== 0) ? (-r / w) : (-r / (eps * norm));\n\t                    } else {\n\t                        x = H[i][i + 1];\n\t                        y = H[i + 1][i];\n\t                        q = (d[i] - p) * (d[i] - p) + e[i] * e[i];\n\t                        t = (x * s - z * r) / q;\n\t                        H[i][n] = t;\n\t                        H[i + 1][n] = (Math.abs(x) > Math.abs(z)) ? ((-r - w * t) / x) : ((-s - y * t) / z);\n\t                    }\n\t\n\t                    t = Math.abs(H[i][n]);\n\t                    if ((eps * t) * t > 1) {\n\t                        for (j = i; j <= n; j++) {\n\t                            H[j][n] = H[j][n] / t;\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        } else if (q < 0) {\n\t            l = n - 1;\n\t\n\t            if (Math.abs(H[n][n - 1]) > Math.abs(H[n - 1][n])) {\n\t                H[n - 1][n - 1] = q / H[n][n - 1];\n\t                H[n - 1][n] = -(H[n][n] - p) / H[n][n - 1];\n\t            } else {\n\t                cdivres = cdiv(0, -H[n - 1][n], H[n - 1][n - 1] - p, q);\n\t                H[n - 1][n - 1] = cdivres[0];\n\t                H[n - 1][n] = cdivres[1];\n\t            }\n\t\n\t            H[n][n - 1] = 0;\n\t            H[n][n] = 1;\n\t            for (i = n - 2; i >= 0; i--) {\n\t                ra = 0;\n\t                sa = 0;\n\t                for (j = l; j <= n; j++) {\n\t                    ra = ra + H[i][j] * H[j][n - 1];\n\t                    sa = sa + H[i][j] * H[j][n];\n\t                }\n\t\n\t                w = H[i][i] - p;\n\t\n\t                if (e[i] < 0) {\n\t                    z = w;\n\t                    r = ra;\n\t                    s = sa;\n\t                } else {\n\t                    l = i;\n\t                    if (e[i] === 0) {\n\t                        cdivres = cdiv(-ra, -sa, w, q);\n\t                        H[i][n - 1] = cdivres[0];\n\t                        H[i][n] = cdivres[1];\n\t                    } else {\n\t                        x = H[i][i + 1];\n\t                        y = H[i + 1][i];\n\t                        vr = (d[i] - p) * (d[i] - p) + e[i] * e[i] - q * q;\n\t                        vi = (d[i] - p) * 2 * q;\n\t                        if (vr === 0 && vi === 0) {\n\t                            vr = eps * norm * (Math.abs(w) + Math.abs(q) + Math.abs(x) + Math.abs(y) + Math.abs(z));\n\t                        }\n\t                        cdivres = cdiv(x * r - z * ra + q * sa, x * s - z * sa - q * ra, vr, vi);\n\t                        H[i][n - 1] = cdivres[0];\n\t                        H[i][n] = cdivres[1];\n\t                        if (Math.abs(x) > (Math.abs(z) + Math.abs(q))) {\n\t                            H[i + 1][n - 1] = (-ra - w * H[i][n - 1] + q * H[i][n]) / x;\n\t                            H[i + 1][n] = (-sa - w * H[i][n] - q * H[i][n - 1]) / x;\n\t                        } else {\n\t                            cdivres = cdiv(-r - y * H[i][n - 1], -s - y * H[i][n], z, q);\n\t                            H[i + 1][n - 1] = cdivres[0];\n\t                            H[i + 1][n] = cdivres[1];\n\t                        }\n\t                    }\n\t\n\t                    t = Math.max(Math.abs(H[i][n - 1]), Math.abs(H[i][n]));\n\t                    if ((eps * t) * t > 1) {\n\t                        for (j = i; j <= n; j++) {\n\t                            H[j][n - 1] = H[j][n - 1] / t;\n\t                            H[j][n] = H[j][n] / t;\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    for (i = 0; i < nn; i++) {\n\t        if (i < low || i > high) {\n\t            for (j = i; j < nn; j++) {\n\t                V[i][j] = H[i][j];\n\t            }\n\t        }\n\t    }\n\t\n\t    for (j = nn - 1; j >= low; j--) {\n\t        for (i = low; i <= high; i++) {\n\t            z = 0;\n\t            for (k = low; k <= Math.min(j, high); k++) {\n\t                z = z + V[i][k] * H[k][j];\n\t            }\n\t            V[i][j] = z;\n\t        }\n\t    }\n\t}\n\t\n\tfunction cdiv(xr, xi, yr, yi) {\n\t    var r, d;\n\t    if (Math.abs(yr) > Math.abs(yi)) {\n\t        r = yi / yr;\n\t        d = yr + r * yi;\n\t        return [(xr + r * xi) / d, (xi - r * xr) / d];\n\t    }\n\t    else {\n\t        r = yr / yi;\n\t        d = yi + r * yr;\n\t        return [(r * xr + xi) / d, (r * xi - xr) / d];\n\t    }\n\t}\n\t\n\tmodule.exports = EigenvalueDecomposition;\n\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar Matrix = __webpack_require__(4);\n\t\n\t// https://github.com/lutzroeder/Mapack/blob/master/Source/LuDecomposition.cs\n\tfunction LuDecomposition(matrix) {\n\t    if (!(this instanceof LuDecomposition)) {\n\t        return new LuDecomposition(matrix);\n\t    }\n\t    matrix = Matrix.checkMatrix(matrix);\n\t\n\t    var lu = matrix.clone(),\n\t        rows = lu.rows,\n\t        columns = lu.columns,\n\t        pivotVector = new Array(rows),\n\t        pivotSign = 1,\n\t        i, j, k, p, s, t, v,\n\t        LUrowi, LUcolj, kmax;\n\t\n\t    for (i = 0; i < rows; i++) {\n\t        pivotVector[i] = i;\n\t    }\n\t\n\t    LUcolj = new Array(rows);\n\t\n\t    for (j = 0; j < columns; j++) {\n\t\n\t        for (i = 0; i < rows; i++) {\n\t            LUcolj[i] = lu[i][j];\n\t        }\n\t\n\t        for (i = 0; i < rows; i++) {\n\t            LUrowi = lu[i];\n\t            kmax = Math.min(i, j);\n\t            s = 0;\n\t            for (k = 0; k < kmax; k++) {\n\t                s += LUrowi[k] * LUcolj[k];\n\t            }\n\t            LUrowi[j] = LUcolj[i] -= s;\n\t        }\n\t\n\t        p = j;\n\t        for (i = j + 1; i < rows; i++) {\n\t            if (Math.abs(LUcolj[i]) > Math.abs(LUcolj[p])) {\n\t                p = i;\n\t            }\n\t        }\n\t\n\t        if (p !== j) {\n\t            for (k = 0; k < columns; k++) {\n\t                t = lu[p][k];\n\t                lu[p][k] = lu[j][k];\n\t                lu[j][k] = t;\n\t            }\n\t\n\t            v = pivotVector[p];\n\t            pivotVector[p] = pivotVector[j];\n\t            pivotVector[j] = v;\n\t\n\t            pivotSign = -pivotSign;\n\t        }\n\t\n\t        if (j < rows && lu[j][j] !== 0) {\n\t            for (i = j + 1; i < rows; i++) {\n\t                lu[i][j] /= lu[j][j];\n\t            }\n\t        }\n\t    }\n\t\n\t    this.LU = lu;\n\t    this.pivotVector = pivotVector;\n\t    this.pivotSign = pivotSign;\n\t}\n\t\n\tLuDecomposition.prototype = {\n\t    isSingular: function () {\n\t        var data = this.LU,\n\t            col = data.columns;\n\t        for (var j = 0; j < col; j++) {\n\t            if (data[j][j] === 0) {\n\t                return true;\n\t            }\n\t        }\n\t        return false;\n\t    },\n\t    get determinant() {\n\t        var data = this.LU;\n\t        if (!data.isSquare())\n\t            throw new Error('Matrix must be square');\n\t        var determinant = this.pivotSign, col = data.columns;\n\t        for (var j = 0; j < col; j++)\n\t            determinant *= data[j][j];\n\t        return determinant;\n\t    },\n\t    get lowerTriangularFactor() {\n\t        var data = this.LU,\n\t            rows = data.rows,\n\t            columns = data.columns,\n\t            X = new Matrix(rows, columns);\n\t        for (var i = 0; i < rows; i++) {\n\t            for (var j = 0; j < columns; j++) {\n\t                if (i > j) {\n\t                    X[i][j] = data[i][j];\n\t                } else if (i === j) {\n\t                    X[i][j] = 1;\n\t                } else {\n\t                    X[i][j] = 0;\n\t                }\n\t            }\n\t        }\n\t        return X;\n\t    },\n\t    get upperTriangularFactor() {\n\t        var data = this.LU,\n\t            rows = data.rows,\n\t            columns = data.columns,\n\t            X = new Matrix(rows, columns);\n\t        for (var i = 0; i < rows; i++) {\n\t            for (var j = 0; j < columns; j++) {\n\t                if (i <= j) {\n\t                    X[i][j] = data[i][j];\n\t                } else {\n\t                    X[i][j] = 0;\n\t                }\n\t            }\n\t        }\n\t        return X;\n\t    },\n\t    get pivotPermutationVector() {\n\t        return this.pivotVector.slice();\n\t    },\n\t    solve: function (value) {\n\t        value = Matrix.checkMatrix(value);\n\t\n\t        var lu = this.LU,\n\t            rows = lu.rows;\n\t\n\t        if (rows !== value.rows)\n\t            throw new Error('Invalid matrix dimensions');\n\t        if (this.isSingular())\n\t            throw new Error('LU matrix is singular');\n\t\n\t        var count = value.columns,\n\t            X = value.subMatrixRow(this.pivotVector, 0, count - 1),\n\t            columns = lu.columns,\n\t            i, j, k;\n\t\n\t        for (k = 0; k < columns; k++) {\n\t            for (i = k + 1; i < columns; i++) {\n\t                for (j = 0; j < count; j++) {\n\t                    X[i][j] -= X[k][j] * lu[i][k];\n\t                }\n\t            }\n\t        }\n\t        for (k = columns - 1; k >= 0; k--) {\n\t            for (j = 0; j < count; j++) {\n\t                X[k][j] /= lu[k][k];\n\t            }\n\t            for (i = 0; i < k; i++) {\n\t                for (j = 0; j < count; j++) {\n\t                    X[i][j] -= X[k][j] * lu[i][k];\n\t                }\n\t            }\n\t        }\n\t        return X;\n\t    }\n\t};\n\t\n\tmodule.exports = LuDecomposition;\n\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar Matrix = __webpack_require__(4);\n\tvar hypotenuse = __webpack_require__(7).hypotenuse;\n\t\n\t//https://github.com/lutzroeder/Mapack/blob/master/Source/QrDecomposition.cs\n\tfunction QrDecomposition(value) {\n\t    if (!(this instanceof QrDecomposition)) {\n\t        return new QrDecomposition(value);\n\t    }\n\t    value = Matrix.checkMatrix(value);\n\t\n\t    var qr = value.clone(),\n\t        m = value.rows,\n\t        n = value.columns,\n\t        rdiag = new Array(n),\n\t        i, j, k, s;\n\t\n\t    for (k = 0; k < n; k++) {\n\t        var nrm = 0;\n\t        for (i = k; i < m; i++) {\n\t            nrm = hypotenuse(nrm, qr[i][k]);\n\t        }\n\t        if (nrm !== 0) {\n\t            if (qr[k][k] < 0) {\n\t                nrm = -nrm;\n\t            }\n\t            for (i = k; i < m; i++) {\n\t                qr[i][k] /= nrm;\n\t            }\n\t            qr[k][k] += 1;\n\t            for (j = k + 1; j < n; j++) {\n\t                s = 0;\n\t                for (i = k; i < m; i++) {\n\t                    s += qr[i][k] * qr[i][j];\n\t                }\n\t                s = -s / qr[k][k];\n\t                for (i = k; i < m; i++) {\n\t                    qr[i][j] += s * qr[i][k];\n\t                }\n\t            }\n\t        }\n\t        rdiag[k] = -nrm;\n\t    }\n\t\n\t    this.QR = qr;\n\t    this.Rdiag = rdiag;\n\t}\n\t\n\tQrDecomposition.prototype = {\n\t    solve: function (value) {\n\t        value = Matrix.checkMatrix(value);\n\t\n\t        var qr = this.QR,\n\t            m = qr.rows;\n\t\n\t        if (value.rows !== m)\n\t            throw new Error('Matrix row dimensions must agree');\n\t        if (!this.isFullRank())\n\t            throw new Error('Matrix is rank deficient');\n\t\n\t        var count = value.columns,\n\t            X = value.clone(),\n\t            n = qr.columns,\n\t            i, j, k, s;\n\t\n\t        for (k = 0; k < n; k++) {\n\t            for (j = 0; j < count; j++) {\n\t                s = 0;\n\t                for (i = k; i < m; i++) {\n\t                    s += qr[i][k] * X[i][j];\n\t                }\n\t                s = -s / qr[k][k];\n\t                for (i = k; i < m; i++) {\n\t                    X[i][j] += s * qr[i][k];\n\t                }\n\t            }\n\t        }\n\t        for (k = n - 1; k >= 0; k--) {\n\t            for (j = 0; j < count; j++) {\n\t                X[k][j] /= this.Rdiag[k];\n\t            }\n\t            for (i = 0; i < k; i++) {\n\t                for (j = 0; j < count; j++) {\n\t                    X[i][j] -= X[k][j] * qr[i][k];\n\t                }\n\t            }\n\t        }\n\t\n\t        return X.subMatrix(0, n - 1, 0, count - 1);\n\t    },\n\t    isFullRank: function () {\n\t        var columns = this.QR.columns;\n\t        for (var i = 0; i < columns; i++) {\n\t            if (this.Rdiag[i] === 0) {\n\t                return false;\n\t            }\n\t        }\n\t        return true;\n\t    },\n\t    get upperTriangularFactor() {\n\t        var qr = this.QR,\n\t            n = qr.columns,\n\t            X = new Matrix(n, n),\n\t            i, j;\n\t        for (i = 0; i < n; i++) {\n\t            for (j = 0; j < n; j++) {\n\t                if (i < j) {\n\t                    X[i][j] = qr[i][j];\n\t                } else if (i === j) {\n\t                    X[i][j] = this.Rdiag[i];\n\t                } else {\n\t                    X[i][j] = 0;\n\t                }\n\t            }\n\t        }\n\t        return X;\n\t    },\n\t    get orthogonalFactor() {\n\t        var qr = this.QR,\n\t            rows = qr.rows,\n\t            columns = qr.columns,\n\t            X = new Matrix(rows, columns),\n\t            i, j, k, s;\n\t\n\t        for (k = columns - 1; k >= 0; k--) {\n\t            for (i = 0; i < rows; i++) {\n\t                X[i][k] = 0;\n\t            }\n\t            X[k][k] = 1;\n\t            for (j = k; j < columns; j++) {\n\t                if (qr[k][k] !== 0) {\n\t                    s = 0;\n\t                    for (i = k; i < rows; i++) {\n\t                        s += qr[i][k] * X[i][j];\n\t                    }\n\t\n\t                    s = -s / qr[k][k];\n\t\n\t                    for (i = k; i < rows; i++) {\n\t                        X[i][j] += s * qr[i][k];\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        return X;\n\t    }\n\t};\n\t\n\tmodule.exports = QrDecomposition;\n\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar Matrix = __webpack_require__(4);\n\t\n\t// https://github.com/lutzroeder/Mapack/blob/master/Source/CholeskyDecomposition.cs\n\tfunction CholeskyDecomposition(value) {\n\t    if (!(this instanceof CholeskyDecomposition)) {\n\t        return new CholeskyDecomposition(value);\n\t    }\n\t    value = Matrix.checkMatrix(value);\n\t    if (!value.isSymmetric())\n\t        throw new Error('Matrix is not symmetric');\n\t\n\t    var a = value,\n\t        dimension = a.rows,\n\t        l = new Matrix(dimension, dimension),\n\t        positiveDefinite = true,\n\t        i, j, k;\n\t\n\t    for (j = 0; j < dimension; j++) {\n\t        var Lrowj = l[j];\n\t        var d = 0;\n\t        for (k = 0; k < j; k++) {\n\t            var Lrowk = l[k];\n\t            var s = 0;\n\t            for (i = 0; i < k; i++) {\n\t                s += Lrowk[i] * Lrowj[i];\n\t            }\n\t            Lrowj[k] = s = (a[j][k] - s) / l[k][k];\n\t            d = d + s * s;\n\t        }\n\t\n\t        d = a[j][j] - d;\n\t\n\t        positiveDefinite &= (d > 0);\n\t        l[j][j] = Math.sqrt(Math.max(d, 0));\n\t        for (k = j + 1; k < dimension; k++) {\n\t            l[j][k] = 0;\n\t        }\n\t    }\n\t\n\t    if (!positiveDefinite) {\n\t        throw new Error('Matrix is not positive definite');\n\t    }\n\t\n\t    this.L = l;\n\t}\n\t\n\tCholeskyDecomposition.prototype = {\n\t    get leftTriangularFactor() {\n\t        return this.L;\n\t    },\n\t    solve: function (value) {\n\t        value = Matrix.checkMatrix(value);\n\t\n\t        var l = this.L,\n\t            dimension = l.rows;\n\t\n\t        if (value.rows !== dimension) {\n\t            throw new Error('Matrix dimensions do not match');\n\t        }\n\t\n\t        var count = value.columns,\n\t            B = value.clone(),\n\t            i, j, k;\n\t\n\t        for (k = 0; k < dimension; k++) {\n\t            for (j = 0; j < count; j++) {\n\t                for (i = 0; i < k; i++) {\n\t                    B[k][j] -= B[i][j] * l[k][i];\n\t                }\n\t                B[k][j] /= l[k][k];\n\t            }\n\t        }\n\t\n\t        for (k = dimension - 1; k >= 0; k--) {\n\t            for (j = 0; j < count; j++) {\n\t                for (i = k + 1; i < dimension; i++) {\n\t                    B[k][j] -= B[i][j] * l[i][k];\n\t                }\n\t                B[k][j] /= l[k][k];\n\t            }\n\t        }\n\t\n\t        return B;\n\t    }\n\t};\n\t\n\tmodule.exports = CholeskyDecomposition;\n\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Created by acastillo on 8/24/15.\n\t */\n\t/**\n\t * Non in-place function definitions, compatible with mathjs code *\n\t */\n\t\n\t'use strict';\n\t\n\tvar Matrix = __webpack_require__(3);\n\t\n\tfunction matrix(A,B){\n\t    return new Matrix(A,B);\n\t}\n\t\n\tfunction ones(rows, cols){\n\t    return Matrix.ones(rows,cols);\n\t}\n\t\n\tfunction eye(rows, cols){\n\t    return Matrix.eye(rows, cols);\n\t}\n\t\n\tfunction zeros(rows, cols){\n\t    return Matrix.zeros(rows, cols);\n\t}\n\t\n\tfunction random(rows, cols){\n\t    return Matrix.rand(rows,cols);\n\t}\n\t\n\tfunction transpose(A){\n\t    if(typeof A == 'number')\n\t        return A;\n\t    var result = A.clone();\n\t    return result.transpose();\n\t}\n\t\n\tfunction add(A, B){\n\t    if(typeof A == 'number'&&typeof B === 'number')\n\t        return A+B;\n\t    if(typeof A == 'number')\n\t        return this.add(B,A);\n\t\n\t    var result = A.clone();\n\t    return result.add(B);\n\t\n\t}\n\t\n\tfunction subtract(A, B){\n\t    if(typeof A == 'number'&&typeof B === 'number')\n\t        return A-B;\n\t    if(typeof A == 'number')\n\t        return this.subtract(B,A);\n\t    var result = A.clone();\n\t    return result.sub(B);\n\t}\n\t\n\tfunction multiply(A, B){\n\t    if(typeof A == 'number'&&typeof B === 'number')\n\t        return A*B;\n\t    if(typeof A == 'number')\n\t        return this.multiply(B,A);\n\t\n\t    var result = A.clone();\n\t\n\t    if(typeof B === 'number')\n\t        result.mul(B);\n\t    else\n\t        result = result.mmul(B);\n\t\n\t    if(result.rows==1&&result.columns==1)\n\t        return result[0][0];\n\t    else\n\t        return result;\n\t\n\t}\n\t\n\tfunction dotMultiply(A, B){\n\t    var result = A.clone();\n\t    return result.mul(B);\n\t}\n\t\n\tfunction dotDivide(A, B){\n\t    var result = A.clone();\n\t    return result.div(B);\n\t}\n\t\n\tfunction diag(A){\n\t    var diag = null;\n\t    var rows = A.rows, cols = A.columns, j, r;\n\t    //It is an array\n\t    if(typeof cols === \"undefined\" && (typeof A)=='object'){\n\t        if(A[0]&&A[0].length){\n\t            rows = A.length;\n\t            cols = A[0].length;\n\t            r = Math.min(rows,cols);\n\t            diag = Matrix.zeros(cols, cols);\n\t            for (j = 0; j < cols; j++) {\n\t                diag[j][j]=A[j][j];\n\t            }\n\t        }\n\t        else{\n\t            cols = A.length;\n\t            diag = Matrix.zeros(cols, cols);\n\t            for (j = 0; j < cols; j++) {\n\t                diag[j][j]=A[j];\n\t            }\n\t        }\n\t\n\t    }\n\t    if(rows == 1){\n\t        diag = Matrix.zeros(cols, cols);\n\t        for (j = 0; j < cols; j++) {\n\t            diag[j][j]=A[0][j];\n\t        }\n\t    }\n\t    else{\n\t        if(rows>0 && cols > 0){\n\t            r = Math.min(rows,cols);\n\t            diag = new Array(r);\n\t            for (j = 0; j < r; j++) {\n\t                diag[j] = A[j][j];\n\t            }\n\t        }\n\t    }\n\t    return diag;\n\t}\n\t\n\tfunction min(A, B){\n\t    if(typeof A==='number' && typeof B ==='number')\n\t        return Math.min(A,B);\n\t    var ii = A.rows, jj = A.columns;\n\t    var result = new Matrix(ii,jj);\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            if (A[i][j] < B[i][j]) {\n\t                result[i][j] = A[i][j];\n\t            }\n\t            else{\n\t                result[i][j] = B[i][j];\n\t            }\n\t        }\n\t    }\n\t    return result;\n\t}\n\t\n\tfunction max(A, B){\n\t    if(typeof A==='number' && typeof B ==='number')\n\t        return Math.max(A,B);\n\t    var ii = A.rows, jj = A.columns;\n\t    var result = new Matrix(ii,jj);\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            if (A[i][j] > B[i][j]) {\n\t                result[i][j] = A[i][j];\n\t            }\n\t            else{\n\t                result[i][j] = B[i][j];\n\t            }\n\t        }\n\t    }\n\t    return result;\n\t}\n\t\n\tfunction sqrt(A){\n\t    if(typeof A==='number' )\n\t        return Math.sqrt(A);\n\t    var ii = A.rows, jj = A.columns;\n\t    var result = new Matrix(ii,jj);\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            result[i][j] = Math.sqrt(A[i][j]);\n\t\n\t        }\n\t    }\n\t    return result;\n\t}\n\t\n\tfunction abs(A){\n\t    if(typeof A==='number' )\n\t        return Math.abs(A);\n\t    var ii = A.rows, jj = A.columns;\n\t    var result = new Matrix(ii,jj);\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            result[i][j] = Math.abs(A[i][j]);\n\t\n\t        }\n\t    }\n\t    return result;\n\t}\n\t\n\tfunction exp(A){\n\t    if(typeof A==='number' )\n\t        return Math.sqrt(A);\n\t    var ii = A.rows, jj = A.columns;\n\t    var result = new Matrix(ii,jj);\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            result[i][j] = Math.exp(A[i][j]);\n\t        }\n\t    }\n\t    return result;\n\t}\n\t\n\tfunction dotPow(A, b){\n\t    if(typeof A==='number' )\n\t        return Math.pow(A,b);\n\t    //console.log(A);\n\t    var ii = A.rows, jj = A.columns;\n\t    var result = new Matrix(ii,jj);\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            result[i][j] = Math.pow(A[i][j],b);\n\t        }\n\t    }\n\t    return result;\n\t}\n\t\n\tfunction solve(A, B){\n\t    return A.solve(B);\n\t}\n\t\n\tfunction inv(A){\n\t    if(typeof A ===\"number\")\n\t        return 1/A;\n\t    return A.inverse();\n\t}\n\t\n\tmodule.exports = {\n\t    transpose:transpose,\n\t    add:add,\n\t    subtract:subtract,\n\t    multiply:multiply,\n\t    dotMultiply:dotMultiply,\n\t    dotDivide:dotDivide,\n\t    diag:diag,\n\t    min:min,\n\t    max:max,\n\t    solve:solve,\n\t    inv:inv,\n\t    sqrt:sqrt,\n\t    exp:exp,\n\t    dotPow:dotPow,\n\t    abs:abs,\n\t    matrix:matrix,\n\t    ones:ones,\n\t    zeros:zeros,\n\t    random:random,\n\t    eye:eye\n\t};\n\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** ml-optimize-lorentzian.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 5ab31adfc0ecf3479ba1\n **/","'use strict';\n\nvar LM = require('ml-curve-fitting');\nvar math = LM.Matrix.algebra;\nvar Matrix = require('ml-matrix');\n\n/**\n * This function calculates the spectrum as a sum of lorentzian functions. The Lorentzian\n * parameters are divided in 3 batches. 1st: centers; 2nd: heights; 3th: widths;\n * @param t Ordinate values\n * @param p Lorentzian parameters\n * @param c Constant parameters(Not used)\n * @returns {*}\n */\nfunction sumOfLorentzians(t,p,c){\n    var nL = p.length/3,factor,i, j,p2, cols = t.rows;\n    var result = Matrix.zeros(t.length,1);\n\n    for(i=0;i<nL;i++){\n        p2 = Math.pow(p[i+nL*2][0]/2,2);\n        factor = p[i+nL][0]*p2;\n        for(j=0;j<cols;j++){\n            result[j][0]+=factor/(Math.pow(t[j][0]-p[i][0],2)+p2);\n        }\n    }\n    return result;\n}\n\n/**\n * This function calculates the spectrum as a sum of gaussian functions. The Gaussian\n * parameters are divided in 3 batches. 1st: centers; 2nd: height; 3th: std's;\n * @param t Ordinate values\n * @param p Gaussian parameters\n * @param c Constant parameters(Not used)\n * @returns {*}\n */\nfunction sumOfGaussians(t,p,c){\n    var nL = p.length/3,factor,i, j, cols = t.rows;\n    var result = Matrix.zeros(t.length,1);\n\n    for(i=0;i<nL;i++){\n        factor = p[i+nL*2][0]*p[i+nL*2][0]/2;\n        for(j=0;j<cols;j++){\n            result[j][0]+=p[i+nL][0]*Math.exp(-(t[i][0]-p[i][0])*(t[i][0]-p[i][0])/factor);\n        }\n    }\n    return result;\n}\n/**\n * Single 4 parameter lorentzian function\n * @param t Ordinate values\n * @param p Lorentzian parameters\n * @param c Constant parameters(Not used)\n * @returns {*}\n */\nfunction singleLorentzian(t,p,c){\n    var factor = p[1][0]*Math.pow(p[2][0]/2,2);\n    var rows = t.rows;\n    var result = new Matrix(t.rows, t.columns);\n    for(var i=0;i<rows;i++){\n        result[i][0]=factor/(Math.pow(t[i][0]-p[0][0],2)+Math.pow(p[2][0]/2,2));\n    }\n    return result;\n}\n\n/**\n * Single 3 parameter gaussian function\n * @param t Ordinate values\n * @param p Gaussian parameters [mean, height, std]\n * @param c Constant parameters(Not used)\n * @returns {*}\n */\nfunction singleGaussian(t,p,c){\n    var factor2 = p[2][0]*p[2][0]/2;\n    var rows = t.rows;\n    var result = new Matrix(t.rows, t.columns);\n    for(var i=0;i<rows;i++){\n        result[i][0]=p[1][0]*Math.exp(-(t[i][0]-p[0][0])*(t[i][0]-p[0][0])/factor2);\n    }\n    return result;\n}\n\n/**\n * * Fits a set of points to a Lorentzian function. Returns the center of the peak, the width at half height, and the height of the signal.\n * @param data,[y]\n * @returns {*[]}\n */\nfunction optimizeSingleLorentzian(xy, peak, opts) {\n    opts = opts || {};\n    var xy2 = parseData(xy, opts.percentage||0);\n\n    if(xy2===null||xy2[0].rows<3){\n        return null; //Cannot run an optimization with less than 3 points\n    }\n\n    var t = xy2[0];\n    var y_data = xy2[1];\n    var maxY = xy2[2];\n    var nbPoints = t.rows, i;\n\n    var weight = [nbPoints / Math.sqrt(y_data.dot(y_data))];\n\n    var opts=Object.create(opts.LMOptions || [  3,    100, 1e-3, 1e-3, 1e-3, 1e-2, 1e-2,    11,    9,        1 ]);\n    //var opts = [  3,    100, 1e-3, 1e-3, 1e-3, 1e-2, 1e-2,    11,    9,        1 ];\n    var consts = [ ];\n    var dt = Math.abs(t[0][0]-t[1][0]);// optional vector of constants\n    var dx = new Matrix([[-dt/10000],[-1e-3],[-dt/10000]]);//-Math.abs(t[0][0]-t[1][0])/100;\n    var p_init = new Matrix([[peak.x],[1],[peak.width]]);\n    var p_min = new Matrix([[peak.x-dt],[0.75],[peak.width/4]]);\n    var p_max = new Matrix([[peak.x+dt],[1.25],[peak.width*4]]);\n\n    var p_fit = LM.optimize(singleLorentzian,p_init,t,y_data,weight,dx,p_min,p_max,consts,opts);\n\n\n    p_fit = p_fit.p;\n    return [p_fit[0],[p_fit[1][0]*maxY],p_fit[2]];\n\n}\n\n/**\n * Fits a set of points to a gaussian bell. Returns the mean of the peak, the std and the height of the signal.\n * @param data,[y]\n * @returns {*[]}\n */\nfunction optimizeSingleGaussian(xy, peak, opts) {\n    opts = opts || {};\n    var xy2 = parseData(xy, opts.percentage||0);\n\n    if(xy2===null||xy2[0].rows<3){\n        return null; //Cannot run an optimization with less than 3 points\n    }\n\n    var t = xy2[0];\n    var y_data = xy2[1];\n    var maxY = xy2[2];\n\n    var nbPoints = t.rows, i;\n\n\n\n    var weight = [nbPoints / Math.sqrt(y_data.dot(y_data))];\n\n    var opts=Object.create(opts.LMOptions || [  3,    100, 1e-3, 1e-3, 1e-3, 1e-2, 1e-2,    11,    9,        1 ]);\n    //var opts = [  3,    100, 1e-3, 1e-3, 1e-3, 1e-2, 1e-2,    11,    9,        1 ];\n    var consts = [ ];                         // optional vector of constants\n    var dt = Math.abs(t[0][0]-t[1][0]);\n    var dx = new Matrix([[-dt/10000],[-1e-3],[-dt/10000]]);//-Math.abs(t[0][0]-t[1][0])/100;\n\n    var dx = new Matrix([[-Math.abs(t[0][0]-t[1][0])/1000],[-1e-3],[-peak.width/1000]]);\n    var p_init = new Matrix([[peak.x],[1],[peak.width]]);\n    var p_min = new Matrix([[peak.x-dt],[0.75],[peak.width/4]]);\n    var p_max = new Matrix([[peak.x+dt],[1.25],[peak.width*4]]);\n    //var p_min = new Matrix([[peak.x-peak.width/4],[0.75],[peak.width/3]]);\n    //var p_max = new Matrix([[peak.x+peak.width/4],[1.25],[peak.width*3]]);\n\n    var p_fit = LM.optimize(singleGaussian,p_init,t,y_data,weight,dx,p_min,p_max,consts,opts);\n    p_fit = p_fit.p;\n    return [p_fit[0],[p_fit[1][0]*maxY],p_fit[2]];\n}\n\n/*\n peaks on group should sorted\n */\nfunction optimizeLorentzianTrain(xy, group, opts){\n    var xy2 = parseData(xy);\n    //console.log(xy2[0].rows);\n    if(xy2===null||xy2[0].rows<3){\n        return null; //Cannot run an optimization with less than 3 points\n    }\n\n    var t = xy2[0];\n    var y_data = xy2[1];\n    var maxY = xy2[2];\n    var currentIndex = 0;\n    var nbPoints = t.length;\n    var nextX;\n    var tI, yI, maxY;\n    var result=[], current;\n    for(var i=0; i<group.length;i++){\n        nextX = group[i].x-group[i].width*2;\n        //console.log(group[i]);\n        while(t[currentIndex++]<nextX&&currentIndex<nbPoints);\n        nextX = group[i].x+group[i].width*2;\n        tI = [];\n        yI = [];\n        while(t[currentIndex]<=nextX&&currentIndex<nbPoints){\n            tI.push(t[currentIndex][0]);\n            yI.push(y_data[currentIndex][0]*maxY);\n            currentIndex++;\n        }\n\n        current=optimizeSingleLorentzian([tI, yI], group[i], opts);\n        if(current){\n            result.push({\"x\":current[0][0],\"y\":current[1][0],\"width\":current[2][0],\"opt\":true});\n        }\n        else{\n            result.push({\"x\":group[i].x,\"y\":group[i].y,\"width\":group[i].width,\"opt\":false});\n        }\n    }\n\n    return result;\n\n}\n\nfunction optimizeGaussianTrain(xy, group, opts){\n    var xy2 = parseData(xy);\n    //console.log(xy2[0].rows);\n    if(xy2===null||xy2[0].rows<3){\n        return null; //Cannot run an optimization with less than 3 points\n    }\n\n    var t = xy2[0];\n    var y_data = xy2[1];\n    var maxY = xy2[2];\n    var currentIndex = 0;\n    var nbPoints = t.length;\n    var nextX;\n    var tI, yI, maxY;\n    var result=[], current;\n    for(var i=0; i<group.length;i++){\n        nextX = group[i].x-group[i].width*2;\n        //console.log(group[i]);\n        while(t[currentIndex++]<nextX&&currentIndex<nbPoints);\n        nextX = group[i].x+group[i].width*2;\n        tI = [];\n        yI = [];\n        while(t[currentIndex]<=nextX&&currentIndex<nbPoints){\n            tI.push(t[currentIndex][0]);\n            yI.push(y_data[currentIndex][0]*maxY);\n            currentIndex++;\n        }\n\n        current=optimizeSingleGaussian([tI, yI], group[i], opts);\n        if(current){\n            result.push({\"x\":current[0][0],\"y\":current[1][0],\"width\":current[2][0],\"opt\":true});\n        }\n        else{\n            result.push({\"x\":group[i].x,\"y\":group[i].y,\"width\":group[i].width,\"opt\":false});\n        }\n    }\n\n    return result;\n}\n\n\n\n/**\n *\n * @param xy A two column matrix containing the x and y data to be fitted\n * @param group A set of initial lorentzian parameters to be optimized [center, heigth, half_width_at_half_height]\n * @returns {Array} A set of final lorentzian parameters [center, heigth, hwhh*2]\n */\nfunction optimizeLorentzianSum(xy, group, opts){\n    var xy2 = parseData(xy);\n\n    if(xy2===null||xy2[0].rows<3){\n        return null; //Cannot run an optimization with less than 3 points\n    }\n\n    var t = xy2[0];\n    var y_data = xy2[1];\n    var maxY = xy2[2];\n    var nbPoints = t.rows, i;\n\n    var weight = [nbPoints / math.sqrt(y_data.dot(y_data))];\n    var opts=Object.create(opts || [  3,    100, 1e-3, 1e-3, 1e-3, 1e-2, 1e-2, 11, 9, 1 ]);\n    var consts = [ ];// optional vector of constants\n\n    var nL = group.length;\n    var p_init = new Matrix(nL*3,1);\n    var p_min =  new Matrix(nL*3,1);\n    var p_max =  new Matrix(nL*3,1);\n    var dx = new Matrix(nL*3,1);\n    var dt = Math.abs(t[0][0]-t[1][0]);\n    for( i=0;i<nL;i++){\n        p_init[i][0] = group[i].x;\n        p_init[i+nL][0] = 1;\n        p_init[i+2*nL][0] = group[i].width;\n\n        p_min[i][0] = group[i].x-dt;//-group[i].width/4;\n        p_min[i+nL][0] = 0;\n        p_min[i+2*nL][0] = group[i].width/4;\n\n        p_max[i][0] = group[i].x+dt;//+group[i].width/4;\n        p_max[i+nL][0] = 1.5;\n        p_max[i+2*nL][0] = group[i].width*4;\n\n        dx[i][0] = -dt/1000;\n        dx[i+nL][0] = -1e-3;\n        dx[i+2*nL][0] = -dt/1000;\n    }\n\n    var dx = -Math.abs(t[0][0]-t[1][0])/10000;\n    var p_fit = LM.optimize(sumOfLorentzians, p_init, t, y_data, weight, dx, p_min, p_max, consts, opts);\n    p_fit=p_fit.p;\n    //Put back the result in the correct format\n    var result = new Array(nL);\n    for( i=0;i<nL;i++){\n        result[i]=[p_fit[i],[p_fit[i+nL][0]*maxY],p_fit[i+2*nL]];\n    }\n\n    return result;\n\n}\n\n/**\n *\n * @param xy A two column matrix containing the x and y data to be fitted\n * @param group A set of initial lorentzian parameters to be optimized [center, heigth, half_width_at_half_height]\n * @returns {Array} A set of final lorentzian parameters [center, heigth, hwhh*2]\n */\nfunction optimizeGaussianSum(xy, group, opts){\n    var xy2 = parseData(xy);\n\n    if(xy2===null||xy2[0].rows<3){\n        return null; //Cannot run an optimization with less than 3 points\n    }\n\n    var t = xy2[0];\n    var y_data = xy2[1];\n    var maxY = xy2[2];\n    var nbPoints = t.rows,i;\n\n    var weight = new Matrix(nbPoints,1);//[nbPoints / math.sqrt(y_data.dot(y_data))];\n    var k = nbPoints / math.sqrt(y_data.dot(y_data));\n    for(i=0;i<nbPoints;i++){\n        weight[i][0]=k;///(y_data[i][0]);\n        //weight[i][0]=k*(2-y_data[i][0]);\n    }\n\n    var opts=Object.create(opts || [  3,    100, 1e-3, 1e-3, 1e-3, 1e-2, 1e-2,    11,    9,        2 ]);\n    //var opts=[  3,    100, 1e-5, 1e-6, 1e-6, 1e-6, 1e-6,    11,    9,        1 ];\n    var consts = [ ];// optional vector of constants\n\n    var nL = group.length;\n    var p_init = new Matrix(nL*3,1);\n    var p_min =  new Matrix(nL*3,1);\n    var p_max =  new Matrix(nL*3,1);\n    var dx = new Matrix(nL*3,1);\n    var dt = Math.abs(t[0][0]-t[1][0]);\n    for( i=0;i<nL;i++){\n        p_init[i][0] = group[i].x;\n        p_init[i+nL][0] = group[i].y/maxY;\n        p_init[i+2*nL][0] = group[i].width;\n\n        p_min[i][0] = group[i].x-dt;\n        p_min[i+nL][0] = group[i].y*0.8/maxY;\n        p_min[i+2*nL][0] = group[i].width/2;\n\n        p_max[i][0] = group[i].x+dt;\n        p_max[i+nL][0] = group[i].y*1.2/maxY;\n        p_max[i+2*nL][0] = group[i].width*2;\n\n        dx[i][0] = -dt/1000;\n        dx[i+nL][0] = -1e-3;\n        dx[i+2*nL][0] = -dt/1000;\n    }\n    //console.log(t);\n    var p_fit = LM.optimize(sumOfLorentzians,p_init,t,y_data,weight,dx,p_min,p_max,consts,opts);\n    p_fit = p_fit.p;\n    //Put back the result in the correct format\n    var result = new Array(nL);\n    for( i=0;i<nL;i++){\n        result[i]=[p_fit[i],[p_fit[i+nL][0]*maxY],p_fit[i+2*nL]];\n    }\n\n    return result;\n\n}\n/**\n *\n * Converts the given input to the required x, y column matrices. y data is normalized to max(y)=1\n * @param xy\n * @returns {*[]}\n */\nfunction parseData(xy, threshold){\n    var nbSeries = xy.length;\n    var t = null;\n    var y_data = null, x,y;\n    var maxY = 0, i,j;\n\n    if(nbSeries==2){\n        //Looks like row wise matrix [x,y]\n        var nbPoints = xy[0].length;\n        //if(nbPoints<3)\n        //    throw new Exception(nbPoints);\n        //else{\n        t = new Array(nbPoints);//new Matrix(nbPoints,1);\n        y_data = new Array(nbPoints);//new Matrix(nbPoints,1);\n        x = xy[0];\n        y = xy[1];\n        if(typeof x[0] === \"number\"){\n            for(i=0;i<nbPoints;i++){\n                t[i]=x[i];\n                y_data[i]=y[i];\n                if(y[i]>maxY)\n                    maxY = y[i];\n            }\n        }\n        else{\n            //It is a colum matrix\n            if(typeof x[0] === \"object\"){\n                for(i=0;i<nbPoints;i++){\n                    t[i]=x[i][0];\n                    y_data[i]=y[i][0];\n                    if(y[i][0]>maxY)\n                        maxY = y[i][0];\n                }\n            }\n\n        }\n\n        //}\n    }\n    else{\n        //Looks like a column wise matrix [[x],[y]]\n        var nbPoints = nbSeries;\n        //if(nbPoints<3)\n        //    throw new SizeException(nbPoints);\n        //else {\n        t = new Array(nbPoints);//new Matrix(nbPoints, 1);\n        y_data = new Array(nbPoints);//new Matrix(nbPoints, 1);\n        for (i = 0; i < nbPoints; i++) {\n            t[i] = xy[i][0];\n            y_data[i] = xy[i][1];\n            if(y_data[i]>maxY)\n                maxY = y_data[i];\n        }\n        //}\n    }\n    for (i = 0; i < nbPoints; i++) {\n        y_data[i]/=maxY;\n    }\n    if(threshold){\n        for (i = nbPoints-1; i >=0; i--) {\n            if(y_data[i]<threshold) {\n                y_data.splice(i,1);\n                t.splice(i,1);\n            }\n        }\n    }\n    if(t.length>0)\n        return [(new Matrix([t])).transpose(),(new Matrix([y_data])).transpose(),maxY];\n    return null;\n}\n\nfunction sizeException(nbPoints) {\n    return new RangeError(\"Not enough points to perform the optimization: \"+nbPoints +\"< 3\");\n}\n\nmodule.exports.optimizeSingleLorentzian = optimizeSingleLorentzian;\nmodule.exports.optimizeLorentzianSum = optimizeLorentzianSum;\nmodule.exports.optimizeSingleGaussian = optimizeSingleGaussian;\nmodule.exports.optimizeGaussianSum = optimizeGaussianSum;\nmodule.exports.singleGaussian = singleGaussian;\nmodule.exports.singleLorentzian = singleLorentzian;\nmodule.exports.optimizeGaussianTrain = optimizeGaussianTrain;\nmodule.exports.optimizeLorentzianTrain = optimizeLorentzianTrain;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/index.js\n ** module id = 0\n ** module chunks = 0\n **/","'use strict';\n\nmodule.exports = require('./LM');\nmodule.exports.Matrix = require('ml-matrix');\nmodule.exports.Matrix.algebra = require('./algebra');\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ml-curve-fitting/src/index.js\n ** module id = 1\n ** module chunks = 0\n **/","/**\n * Created by acastillo on 8/5/15.\n */\nvar Matrix = require(\"ml-matrix\");\nvar math = require(\"./algebra\");\n\nvar DEBUG = false;\n/** Levenberg Marquardt curve-fitting: minimize sum of weighted squared residuals\n ----------  INPUT  VARIABLES  -----------\n func   = function of n independent variables, 't', and m parameters, 'p',\n returning the simulated model: y_hat = func(t,p,c)\n p      = n-vector of initial guess of parameter values\n t      = m-vectors or matrix of independent variables (used as arg to func)\n y_dat  = m-vectors or matrix of data to be fit by func(t,p)\n weight = weighting vector for least squares fit ( weight >= 0 ) ...\n inverse of the standard measurement errors\n Default:  sqrt(d.o.f. / ( y_dat' * y_dat ))\n dp     = fractional increment of 'p' for numerical derivatives\n dp(j)>0 central differences calculated\n dp(j)<0 one sided 'backwards' differences calculated\n dp(j)=0 sets corresponding partials to zero; i.e. holds p(j) fixed\n Default:  0.001;\n p_min  = n-vector of lower bounds for parameter values\n p_max  = n-vector of upper bounds for parameter values\n c      = an optional matrix of values passed to func(t,p,c)\n opts   = vector of algorithmic parameters\n parameter    defaults    meaning\n opts(1)  =  prnt            3        >1 intermediate results; >2 plots\n opts(2)  =  MaxIter      10*Npar     maximum number of iterations\n opts(3)  =  epsilon_1       1e-3     convergence tolerance for gradient\n opts(4)  =  epsilon_2       1e-3     convergence tolerance for parameters\n opts(5)  =  epsilon_3       1e-3     convergence tolerance for Chi-square\n opts(6)  =  epsilon_4       1e-2     determines acceptance of a L-M step\n opts(7)  =  lambda_0        1e-2     initial value of L-M paramter\n opts(8)  =  lambda_UP_fac   11       factor for increasing lambda\n opts(9)  =  lambda_DN_fac    9       factor for decreasing lambda\n opts(10) =  Update_Type      1       1: Levenberg-Marquardt lambda update\n 2: Quadratic update\n 3: Nielsen's lambda update equations\n\n ----------  OUTPUT  VARIABLES  -----------\n p       = least-squares optimal estimate of the parameter values\n X2      = Chi squared criteria\n sigma_p = asymptotic standard error of the parameters\n sigma_y = asymptotic standard error of the curve-fit\n corr    = correlation matrix of the parameters\n R_sq    = R-squared cofficient of multiple determination\n cvg_hst = convergence history\n\n Henri Gavin, Dept. Civil & Environ. Engineering, Duke Univ. 22 Sep 2013\n modified from: http://octave.sourceforge.net/optim/function/leasqr.html\n using references by\n Press, et al., Numerical Recipes, Cambridge Univ. Press, 1992, Chapter 15.\n Sam Roweis       http://www.cs.toronto.edu/~roweis/notes/lm.pdf\n Manolis Lourakis http://www.ics.forth.gr/~lourakis/levmar/levmar.pdf\n Hans Nielson     http://www2.imm.dtu.dk/~hbn/publ/TR9905.ps\n Mathworks        optimization toolbox reference manual\n K. Madsen, H.B., Nielsen, and O. Tingleff\n http://www2.imm.dtu.dk/pubdb/views/edoc_download.php/3215/pdf/imm3215.pdf\n */\nvar LM = {\n\n    optimize: function(func,p,t,y_dat,weight,dp,p_min,p_max,c,opts){\n\n        var tensor_parameter = 0;\t\t\t// set to 1 of parameter is a tensor\n\n        var iteration  = 0;\t\t\t// iteration counter\n        //func_calls = 0;\t\t\t// running count of function evaluations\n\n        if((typeof p[0])!=\"object\"){\n            for(var i=0;i< p.length;i++){\n                p[i]=[p[i]];\n            }\n\n        }\n        //p = p(:); y_dat = y_dat(:);\t\t// make column vectors\n        var i,k;\n        var eps = 2^-52;\n        var Npar   = p.length;//length(p); \t\t\t// number of parameters\n        var Npnt   = y_dat.length;//length(y_dat);\t\t// number of data points\n        var p_old  = Matrix.zeros(Npar,1);\t\t// previous set of parameters\n        var y_old  = Matrix.zeros(Npnt,1);\t\t// previous model, y_old = y_hat(t;p_old)\n        var X2     = 1e-2/eps;\t\t\t// a really big initial Chi-sq value\n        var X2_old = 1e-2/eps;\t\t\t// a really big initial Chi-sq value\n        var J =  Matrix.zeros(Npnt,Npar);\n\n\n        if (t.length != y_dat.length) {\n            console.log('lm.m error: the length of t must equal the length of y_dat');\n\n            length_t = t.length;\n            length_y_dat = y_dat.length;\n            var X2 = 0, corr = 0, sigma_p = 0, sigma_y = 0, R_sq = 0, cvg_hist = 0;\n            if (!tensor_parameter) {\n                return;\n            }\n        }\n\n        weight = weight||Math.sqrt((Npnt-Npar+1)/(math.multiply(math.transpose(y_dat),y_dat)));\n        dp = dp || 0.001;\n        p_min   = p_min || math.multiply(Math.abs(p),-100);\n        p_max   = p_max || math.multiply(Math.abs(p),100);\n        c = c || 1;\n        // Algorithmic Paramters\n        //prnt MaxIter  eps1  eps2  epx3  eps4  lam0  lamUP lamDN UpdateType\n        opts = opts ||[  3,10*Npar, 1e-3, 1e-3, 1e-3, 1e-2, 1e-2, 11, 9, 1 ];\n\n        var prnt          = opts[0];\t// >1 intermediate results; >2 plots\n        var MaxIter       = opts[1];\t// maximum number of iterations\n        var epsilon_1     = opts[2];\t// convergence tolerance for gradient\n        var epsilon_2     = opts[3];\t// convergence tolerance for parameter\n        var epsilon_3     = opts[4];\t// convergence tolerance for Chi-square\n        var epsilon_4     = opts[5];\t// determines acceptance of a L-M step\n        var lambda_0      = opts[6];\t// initial value of damping paramter, lambda\n        var lambda_UP_fac = opts[7];\t// factor for increasing lambda\n        var lambda_DN_fac = opts[8];\t// factor for decreasing lambda\n        var Update_Type   = opts[9];\t// 1: Levenberg-Marquardt lambda update\n        // 2: Quadratic update\n        // 3: Nielsen's lambda update equations\n\n        if ( tensor_parameter && prnt == 3 ) prnt = 2;\n\n\n        if(!dp.length || dp.length == 1){\n            var dp_array = new Array(Npar);\n            for(var i=0;i<Npar;i++)\n                dp_array[i]=[dp];\n            dp=dp_array;\n        }\n\n        // indices of the parameters to be fit\n        var idx   = [];\n        for(i=0;i<dp.length;i++){\n            if(dp[i][0]!=0){\n                idx.push(i);\n            }\n        }\n\n        var Nfit = idx.length;\t\t\t// number of parameters to fit\n        var stop = false;\t\t\t\t// termination flag\n\n        var weight_sq = null;\n        //console.log(weight);\n        if ( !weight.length || weight.length < Npnt )\t{\n            // squared weighting vector\n            //weight_sq = ( weight(1)*ones(Npnt,1) ).^2;\n            //console.log(\"weight[0] \"+typeof weight[0]);\n            var tmp = math.multiply(Matrix.ones(Npnt,1),weight[0]);\n            weight_sq = math.dotMultiply(tmp,tmp);\n        }\n        else{\n            //weight_sq = (weight(:)).^2;\n            weight_sq = math.dotMultiply(weight,weight);\n        }\n\n\n        // initialize Jacobian with finite difference calculation\n        //console.log(\"J \"+weight_sq);\n        var result = this.lm_matx(func,t,p_old,y_old,1,J,p,y_dat,weight_sq,dp,c);\n        var JtWJ = result.JtWJ,JtWdy=result.JtWdy,X2=result.Chi_sq,y_hat=result.y_hat,J=result.J;\n        //[JtWJ,JtWdy,X2,y_hat,J] = this.lm_matx(func,t,p_old,y_old,1,J,p,y_dat,weight_sq,dp,c);\n        //console.log(JtWJ);\n\n        if ( Math.max(Math.abs(JtWdy)) < epsilon_1 ){\n            console.log(' *** Your Initial Guess is Extremely Close to Optimal ***')\n            console.log(' *** epsilon_1 = ', epsilon_1);\n            stop = true;\n        }\n\n\n        switch(Update_Type){\n            case 1: // Marquardt: init'l lambda\n                lambda  = lambda_0;\n                break;\n            default:    // Quadratic and Nielsen\n                lambda  = lambda_0 * Math.max(math.diag(JtWJ));\n                nu=2;\n        }\n        //console.log(X2);\n        X2_old = X2; // previous value of X2\n        //console.log(MaxIter+\" \"+Npar);\n        //var cvg_hst = Matrix.ones(MaxIter,Npar+3);\t\t// initialize convergence history\n        var h = null;\n        while ( !stop && iteration <= MaxIter ) {\t\t// --- Main Loop\n            iteration = iteration + 1;\n            // incremental change in parameters\n            switch(Update_Type){\n                case 1:\t\t\t\t\t// Marquardt\n                    //h = ( JtWJ + lambda * math.diag(math.diag(JtWJ)) ) \\ JtWdy;\n                    //h = math.multiply(math.inv(JtWdy),math.add(JtWJ,math.multiply(lambda,math.diag(math.diag(Npar)))));\n                    h = math.solve(math.add(JtWJ,math.multiply(math.diag(math.diag(JtWJ)),lambda)),JtWdy);\n                    break;\n                default:\t\t\t\t\t// Quadratic and Nielsen\n                    //h = ( JtWJ + lambda * math.eye(Npar) ) \\ JtWdy;\n\n                    h = math.solve(math.add(JtWJ,math.multiply( Matrix.eye(Npar),lambda)),JtWdy);\n            }\n\n            /*for(var k=0;k< h.length;k++){\n             h[k]=[h[k]];\n             }*/\n            //console.log(\"h \"+h);\n            //h=math.matrix(h);\n            //  big = max(abs(h./p)) > 2;\n            //this is a big step\n            // --- Are parameters [p+h] much better than [p] ?\n            var hidx = new Array(idx.length);\n            for(k=0;k<idx.length;k++){\n                hidx[k]=h[idx[k]];\n            }\n            var p_try = math.add(p, hidx);// update the [idx] elements\n\n            for(k=0;k<p_try.length;k++){\n                p_try[k][0]=Math.min(Math.max(p_min[k][0],p_try[k][0]),p_max[k][0]);\n            }\n            // p_try = Math.min(Math.max(p_min,p_try),p_max);           // apply constraints\n\n            var delta_y = math.subtract(y_dat, func(t,p_try,c));       // residual error using p_try\n            //func_calls = func_calls + 1;\n            //X2_try = delta_y' * ( delta_y .* weight_sq );  // Chi-squared error criteria\n\n            var X2_try = math.multiply(math.transpose(delta_y),math.dotMultiply(delta_y,weight_sq));\n\n            if ( Update_Type == 2 ){  \t\t\t  // Quadratic\n                //    One step of quadratic line update in the h direction for minimum X2\n                //var alpha =  JtWdy'*h / ( (X2_try - X2)/2 + 2*JtWdy'*h ) ;\n                var JtWdy_th = math.multiply(math.transpose(JtWdy),h);\n                var alpha =  math.multiply(JtWdy_th,math.inv(math.add(math.multiply(math.subtract(X2_try - X2),1/2)),math.multiply(JtWdy_th,2)));//JtWdy'*h / ( (X2_try - X2)/2 + 2*JtWdy'*h ) ;\n\n                h = math.multiply(alpha, h);\n                for(var k=0;k<idx.length;k++){\n                    hidx[k]=h[idx[k]];\n                }\n\n                p_try = math.add(p ,hidx);                     // update only [idx] elements\n                p_try = math.min(math.max(p_min,p_try),p_max);          // apply constraints\n\n                delta_y = math.subtract(y_dat, func(t,p_try,c));      // residual error using p_try\n                // func_calls = func_calls + 1;\n                //X2_try = delta_y' * ( delta_y .* weight_sq ); // Chi-squared error criteria\n                X2_try = math.multiply(math.transpose(delta_y), mat.dotMultiply(delta_y, weight_sq));\n            }\n\n            //rho = (X2 - X2_try) / ( 2*h' * (lambda * h + JtWdy) ); // Nielsen\n            var rho = (X2-X2_try)/math.multiply(math.multiply(math.transpose(h),2),math.add(math.multiply(lambda, h),JtWdy));\n            //console.log(\"rho \"+rho);\n            if ( rho > epsilon_4 ) {\t\t// it IS significantly better\n                //console.log(\"Here\");\n                dX2 = X2 - X2_old;\n                X2_old = X2;\n                p_old = p;\n                y_old = y_hat;\n                p = p_try;\t\t\t// accept p_try\n\n                result = this.lm_matx(func, t, p_old, y_old, dX2, J, p, y_dat, weight_sq, dp, c);\n                JtWJ = result.JtWJ,JtWdy=result.JtWdy,X2=result.Chi_sq,y_hat=result.y_hat,J=result.J;\n                // decrease lambda ==> Gauss-Newton method\n\n                switch (Update_Type) {\n                    case 1:\t\t\t\t\t\t\t// Levenberg\n                        lambda = Math.max(lambda / lambda_DN_fac, 1.e-7);\n                        break;\n                    case 2:\t\t\t\t\t\t\t// Quadratic\n                        lambda = Math.max(lambda / (1 + alpha), 1.e-7);\n                        break;\n                    case 3:\t\t\t\t\t\t\t// Nielsen\n                        lambda = math.multiply(Math.max(1 / 3, 1 - (2 * rho - 1) ^ 3),lambda);\n                        nu = 2;\n                        break;\n                }\n            }\n            else {\t\t\t\t\t// it IS NOT better\n                X2 = X2_old;\t\t\t// do not accept p_try\n                if (iteration%(2 * Npar)==0) {\t// rank-1 update of Jacobian\n                    result = this.lm_matx(func, t, p_old, y_old, -1, J, p, y_dat, weight_sq, dp, c);\n                    JtWJ = result.JtWJ,JtWdy=result.JtWdy,dX2=result.Chi_sq,y_hat=result.y_hat,J=result.J;\n                }\n\n                // increase lambda  ==> gradient descent method\n                switch (Update_Type) {\n                    case 1:\t\t\t\t\t\t\t// Levenberg\n                        lambda = Math.min(lambda * lambda_UP_fac, 1.e7);\n                        break;\n                    case 2:\t\t\t\t\t\t\t// Quadratic\n                        lambda = lambda + Math.abs((X2_try - X2) / 2 / alpha);\n                        break;\n                    case 3:\t\t\t\t\t\t// Nielsen\n                        lambda = lambda * nu;\n                        nu = 2 * nu;\n                        break;\n                }\n            }\n        }// --- End of Main Loop\n\n        // --- convergence achieved, find covariance and confidence intervals\n\n        // equal weights for paramter error analysis\n        weight_sq = math.multiply(math.multiply(math.transpose(delta_y),delta_y), Matrix.ones(Npnt,1));\n\n        weight_sq.apply(function(i,j){\n            weight_sq[i][j] = (Npnt-Nfit+1)/weight_sq[i][j];\n        });\n        //console.log(weight_sq);\n        result = this.lm_matx(func,t,p_old,y_old,-1,J,p,y_dat,weight_sq,dp,c);\n        JtWJ = result.JtWJ,JtWdy=result.JtWdy,X2=result.Chi_sq,y_hat=result.y_hat,J=result.J;\n\n        /*if nargout > 2\t\t\t\t// standard error of parameters\n         covar = inv(JtWJ);\n         sigma_p = sqrt(diag(covar));\n         end\n\n         if nargout > 3\t\t\t\t// standard error of the fit\n         //  sigma_y = sqrt(diag(J * covar * J'));\t// slower version of below\n         sigma_y = zeros(Npnt,1);\n         for i=1:Npnt\n         sigma_y(i) = J(i,:) * covar * J(i,:)';\n         end\n         sigma_y = sqrt(sigma_y);\n         end\n\n         if nargout > 4\t\t\t\t// parameter correlation matrix\n         corr = covar ./ [sigma_p*sigma_p'];\n         end\n\n         if nargout > 5\t\t\t\t// coefficient of multiple determination\n         R_sq = corrcoef([y_dat y_hat]);\n         R_sq = R_sq(1,2).^2;\n         end\n\n         if nargout > 6\t\t\t\t// convergence history\n         cvg_hst = cvg_hst(1:iteration,:);\n         end*/\n\n        // endfunction  # ---------------------------------------------------------- LM\n\n        return { p:p, X2:X2};\n    },\n\n    lm_FD_J:function(func,t,p,y,dp,c) {\n        // J = lm_FD_J(func,t,p,y,{dp},{c})\n        //\n        // partial derivatives (Jacobian) dy/dp for use with lm.m\n        // computed via Finite Differences\n        // Requires n or 2n function evaluations, n = number of nonzero values of dp\n        // -------- INPUT VARIABLES ---------\n        // func = function of independent variables, 't', and parameters, 'p',\n        //        returning the simulated model: y_hat = func(t,p,c)\n        // t  = m-vector of independent variables (used as arg to func)\n        // p  = n-vector of current parameter values\n        // y  = func(t,p,c) n-vector initialised by user before each call to lm_FD_J\n        // dp = fractional increment of p for numerical derivatives\n        //      dp(j)>0 central differences calculated\n        //      dp(j)<0 one sided differences calculated\n        //      dp(j)=0 sets corresponding partials to zero; i.e. holds p(j) fixed\n        //      Default:  0.001;\n        // c  = optional vector of constants passed to y_hat = func(t,p,c)\n        //---------- OUTPUT VARIABLES -------\n        // J  = Jacobian Matrix J(i,j)=dy(i)/dp(j)\ti=1:n; j=1:m\n\n        //   Henri Gavin, Dept. Civil & Environ. Engineering, Duke Univ. November 2005\n        //   modified from: ftp://fly.cnuce.cnr.it/pub/software/octave/leasqr/\n        //   Press, et al., Numerical Recipes, Cambridge Univ. Press, 1992, Chapter 15.\n\n        var m = y.length;\t\t\t// number of data points\n        var n = p.length;\t\t\t// number of parameters\n\n        dp = dp || math.multiply( Matrix.ones(n, 1), 0.001);\n\n        var ps = p.clone();//JSON.parse(JSON.stringify(p));\n        //var ps = $.extend(true, [], p);\n        var J = new Matrix(m,n), del =new Array(n);         // initialize Jacobian to Zero\n\n        for (var j = 0;j < n; j++) {\n            //console.log(j+\" \"+dp[j]+\" \"+p[j]+\" \"+ps[j]+\" \"+del[j]);\n            del[j] = dp[j]*(1+Math.abs(p[j][0]));  // parameter perturbation\n            p[j] = [ps[j][0]+del[j]];\t      // perturb parameter p(j)\n            //console.log(j+\" \"+dp[j]+\" \"+p[j]+\" \"+ps[j]+\" \"+del[j]);\n\n            if (del[j] != 0){\n                y1 = func(t, p, c);\n                //func_calls = func_calls + 1;\n                if (dp[j][0] < 0) {\t\t// backwards difference\n                    //J(:,j) = math.dotDivide(math.subtract(y1, y),del[j]);//. / del[j];\n                    //console.log(del[j]);\n                    //console.log(y);\n                    var column = math.dotDivide(math.subtract(y1, y),del[j]);\n                    for(var k=0;k< m;k++){\n                        J[k][j]=column[k][0];\n                    }\n                    //console.log(column);\n                }\n                else{\n                    p[j][0] = ps[j][0] - del[j];\n                    //J(:,j) = (y1 - feval(func, t, p, c)). / (2. * del[j]);\n                    var column = math.dotDivide(math.subtract(y1,func(t,p,c)),2*del[j]);\n                    for(var k=0;k< m;k++){\n                        J[k][j]=column[k][0];\n                    }\n\n                }\t\t\t// central difference, additional func call\n            }\n\n            p[j] = ps[j];\t\t// restore p(j)\n\n        }\n        //console.log(\"lm_FD_J: \"+ JSON.stringify(J));\n        return J;\n\n    },\n\n    // endfunction # -------------------------------------------------- LM_FD_J\n    lm_Broyden_J: function(p_old,y_old,J,p,y){\n        // J = lm_Broyden_J(p_old,y_old,J,p,y)\n        // carry out a rank-1 update to the Jacobian matrix using Broyden's equation\n        //---------- INPUT VARIABLES -------\n        // p_old = previous set of parameters\n        // y_old = model evaluation at previous set of parameters, y_hat(t;p_old)\n        // J  = current version of the Jacobian matrix\n        // p     = current  set of parameters\n        // y     = model evaluation at current  set of parameters, y_hat(t;p)\n        //---------- OUTPUT VARIABLES -------\n        // J = rank-1 update to Jacobian Matrix J(i,j)=dy(i)/dp(j)\ti=1:n; j=1:m\n        //console.log(p+\" X \"+ p_old)\n        var h  = math.subtract(p, p_old);\n\n        //console.log(\"hhh \"+h);\n        var h_t = math.transpose(h);\n        h_t.div(math.multiply(h_t,h));\n\n        //console.log(h_t);\n        //J = J + ( y - y_old - J*h )*h' / (h'*h);\t// Broyden rank-1 update eq'n\n        J = math.add(J, math.multiply(math.subtract(y, math.add(y_old,math.multiply(J,h))),h_t));\n        return J;\n        // endfunction # ---------------------------------------------- LM_Broyden_J\n    },\n\n    lm_matx : function (func,t,p_old,y_old,dX2,J,p,y_dat,weight_sq,dp,c,iteration){\n        // [JtWJ,JtWdy,Chi_sq,y_hat,J] = this.lm_matx(func,t,p_old,y_old,dX2,J,p,y_dat,weight_sq,{da},{c})\n        //\n        // Evaluate the linearized fitting matrix, JtWJ, and vector JtWdy,\n        // and calculate the Chi-squared error function, Chi_sq\n        // Used by Levenberg-Marquard algorithm, lm.m\n        // -------- INPUT VARIABLES ---------\n        // func   = function ofpn independent variables, p, and m parameters, p,\n        //         returning the simulated model: y_hat = func(t,p,c)\n        // t      = m-vectors or matrix of independent variables (used as arg to func)\n        // p_old  = n-vector of previous parameter values\n        // y_old  = m-vector of previous model ... y_old = y_hat(t;p_old);\n        // dX2    = previous change in Chi-squared criteria\n        // J   = m-by-n Jacobian of model, y_hat, with respect to parameters, p\n        // p      = n-vector of current  parameter values\n        // y_dat  = n-vector of data to be fit by func(t,p,c)\n        // weight_sq = square of the weighting vector for least squares fit ...\n        //\t    inverse of the standard measurement errors\n        // dp     = fractional increment of 'p' for numerical derivatives\n        //          dp(j)>0 central differences calculated\n        //          dp(j)<0 one sided differences calculated\n        //          dp(j)=0 sets corresponding partials to zero; i.e. holds p(j) fixed\n        //          Default:  0.001;\n        // c      = optional vector of constants passed to y_hat = func(t,p,c)\n        //---------- OUTPUT VARIABLES -------\n        // JtWJ\t = linearized Hessian matrix (inverse of covariance matrix)\n        // JtWdy   = linearized fitting vector\n        // Chi_sq = Chi-squared criteria: weighted sum of the squared residuals WSSR\n        // y_hat  = model evaluated with parameters 'p'\n        // J   = m-by-n Jacobian of model, y_hat, with respect to parameters, p\n\n        //   Henri Gavin, Dept. Civil & Environ. Engineering, Duke Univ. November 2005\n        //   modified from: ftp://fly.cnuce.cnr.it/pub/software/octave/leasqr/\n        //   Press, et al., Numerical Recipes, Cambridge Univ. Press, 1992, Chapter 15.\n\n\n        var Npnt = y_dat.length;\t\t// number of data points\n        var Npar = p.length;\t\t// number of parameters\n\n        dp = dp || 0.001;\n\n\n        //var JtWJ = new Matrix.zeros(Npar);\n        //var JtWdy  = new Matrix.zeros(Npar,1);\n\n        var y_hat = func(t,p,c);\t// evaluate model using parameters 'p'\n        //func_calls = func_calls + 1;\n        //console.log(J);\n        if ( (iteration%(2*Npar))==0 || dX2 > 0 ) {\n            //console.log(\"Par\");\n            J = this.lm_FD_J(func, t, p, y_hat, dp, c);\t\t// finite difference\n        }\n        else{\n            //console.log(\"ImPar\");\n            J = this.lm_Broyden_J(p_old, y_old, J, p, y_hat); // rank-1 update\n        }\n        var delta_y = math.subtract(y_dat, y_hat);\t// residual error between model and data\n        //console.log(delta_y[0][0]);\n        //console.log(delta_y.rows+\" \"+delta_y.columns+\" \"+JSON.stringify(weight_sq));\n        //var Chi_sq = delta_y' * ( delta_y .* weight_sq ); \t// Chi-squared error criteria\n        var Chi_sq = math.multiply(math.transpose(delta_y),math.dotMultiply(delta_y,weight_sq));\n        //JtWJ  = J' * ( J .* ( weight_sq * ones(1,Npar) ) );\n        var Jt = math.transpose(J);\n\n        //console.log(weight_sq);\n\n        var JtWJ = math.multiply(Jt, math.dotMultiply(J,math.multiply(weight_sq, Matrix.ones(1,Npar))));\n\n        //JtWdy = J' * ( weight_sq .* delta_y );\n        var JtWdy = math.multiply(Jt, math.dotMultiply(weight_sq,delta_y));\n\n\n        return {JtWJ:JtWJ,JtWdy:JtWdy,Chi_sq:Chi_sq,y_hat:y_hat,J:J};\n        // endfunction  # ------------------------------------------------------ LM_MATX\n    }\n\n\n\n};\n\nmodule.exports = LM;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ml-curve-fitting/src/LM.js\n ** module id = 2\n ** module chunks = 0\n **/","'use strict';\n\nmodule.exports = require('./matrix');\nmodule.exports.Decompositions = module.exports.DC = require('./decompositions');\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ml-matrix/src/index.js\n ** module id = 3\n ** module chunks = 0\n **/","'use strict';\n\nvar Asplice = Array.prototype.splice,\n    Aconcat = Array.prototype.concat;\n\n// For performance : http://jsperf.com/clone-array-slice-vs-while-vs-for\nfunction slice(arr) {\n    var i = 0,\n        ii = arr.length,\n        result = new Array(ii);\n    for (; i < ii; i++) {\n        result[i] = arr[i];\n    }\n    return result;\n}\n\n/**\n * Real matrix.\n * @constructor\n * @param {number|Array} nRows - Number of rows of the new matrix or a 2D array containing the data.\n * @param {number|boolean} [nColumns] - Number of columns of the new matrix or a boolean specifying if the input array should be cloned\n */\nfunction Matrix(nRows, nColumns) {\n    var i = 0, rows, columns, matrix, newInstance;\n    if (Array.isArray(nRows)) {\n        newInstance = nColumns;\n        matrix = newInstance ? slice(nRows) : nRows;\n        nRows = matrix.length;\n        nColumns = matrix[0].length;\n        if (typeof nColumns === 'undefined') {\n            throw new TypeError('Data must be a 2D array');\n        }\n        if (nRows > 0 && nColumns > 0) {\n            for (; i < nRows; i++) {\n                if (matrix[i].length !== nColumns) {\n                    throw new RangeError('Inconsistent array dimensions');\n                } else if (newInstance) {\n                    matrix[i] = slice(matrix[i]);\n                }\n            }\n        } else {\n            throw new RangeError('Invalid dimensions: ' + nRows + 'x' + nColumns);\n        }\n    } else if (typeof nRows === 'number') { // Create empty matrix\n        if (nRows > 0 && nColumns > 0) {\n            matrix = new Array(nRows);\n            for (; i < nRows; i++) {\n                matrix[i] = new Array(nColumns);\n            }\n        } else {\n            throw new RangeError('Invalid dimensions: ' + nRows + 'x' + nColumns);\n        }\n    } else {\n        throw new TypeError('Invalid arguments');\n    }\n\n    Object.defineProperty(matrix, 'rows', {writable: true, value: nRows});\n    Object.defineProperty(matrix, 'columns', {writable: true, value: nColumns});\n\n    matrix.__proto__ = Matrix.prototype;\n\n    return matrix;\n}\n\n/**\n * Constructs a Matrix with the chosen dimensions from a 1D array.\n * @param {number} newRows - Number of rows\n * @param {number} newColumns - Number of columns\n * @param {Array} newData - A 1D array containing data for the matrix\n * @returns {Matrix} - The new matrix\n */\nMatrix.from1DArray = function from1DArray(newRows, newColumns, newData) {\n    var length, data, i = 0;\n\n    length = newRows * newColumns;\n    if (length !== newData.length)\n        throw new RangeError('Data length does not match given dimensions');\n\n    data = new Array(newRows);\n    for (; i < newRows; i++) {\n        data[i] = newData.slice(i * newColumns, (i + 1) * newColumns);\n    }\n    return new Matrix(data);\n};\n\n/**\n * Creates a row vector, a matrix with only one row.\n * @param {Array} newData - A 1D array containing data for the vector\n * @returns {Matrix} - The new matrix\n */\nMatrix.rowVector = function rowVector(newData) {\n    return new Matrix([newData]);\n};\n\n/**\n * Creates a column vector, a matrix with only one column.\n * @param {Array} newData - A 1D array containing data for the vector\n * @returns {Matrix} - The new matrix\n */\nMatrix.columnVector = function columnVector(newData) {\n    var l = newData.length, vector = new Array(l);\n    for (var i = 0; i < l; i++)\n        vector[i] = [newData[i]];\n    return new Matrix(vector);\n};\n\n/**\n * Creates an empty matrix with the given dimensions. Values will be undefined. Same as using new Matrix(rows, columns).\n * @param {number} rows - Number of rows\n * @param {number} columns - Number of columns\n * @returns {Matrix} - The new matrix\n */\nMatrix.empty = function empty(rows, columns) {\n    return new Matrix(rows, columns);\n};\n\n/**\n * Creates a matrix with the given dimensions. Values will be set to zero.\n * @param {number} rows - Number of rows\n * @param {number} columns - Number of columns\n * @returns {Matrix} - The new matrix\n */\nMatrix.zeros = function zeros(rows, columns) {\n    return Matrix.empty(rows, columns).fill(0);\n};\n\n/**\n * Creates a matrix with the given dimensions. Values will be set to one.\n * @param {number} rows - Number of rows\n * @param {number} columns - Number of columns\n * @returns {Matrix} - The new matrix\n */\nMatrix.ones = function ones(rows, columns) {\n    return Matrix.empty(rows, columns).fill(1);\n};\n\n/**\n * Creates a matrix with the given dimensions. Values will be randomly set using Math.random().\n * @param {number} rows - Number of rows\n * @param {number} columns - Number of columns\n * @returns {Matrix} The new matrix\n */\nMatrix.rand = function rand(rows, columns) {\n    var matrix = Matrix.empty(rows, columns);\n    for (var i = 0, ii = matrix.rows; i < ii; i++) {\n        for (var j = 0, jj = matrix.columns; j < jj; j++) {\n            matrix[i][j] = Math.random();\n        }\n    }\n    return matrix;\n};\n\n/**\n * Creates an identity matrix with the given dimension. Values of the diagonal will be 1 and other will be 0.\n * @param {number} n - Number of rows and columns\n * @returns {Matrix} - The new matrix\n */\nMatrix.eye = function eye(n) {\n    var matrix = Matrix.zeros(n, n), l = matrix.rows;\n    for (var i = 0; i < l; i++) {\n        matrix[i][i] = 1;\n    }\n    return matrix;\n};\n\n/**\n * Creates a diagonal matrix based on the given array.\n * @param {Array} data - Array containing the data for the diagonal\n * @returns {Matrix} - The new matrix\n */\nMatrix.diag = function diag(data) {\n    var l = data.length, matrix = Matrix.zeros(l, l);\n    for (var i = 0; i < l; i++) {\n        matrix[i][i] = data[i];\n    }\n    return matrix;\n};\n\n/**\n * Creates an array of indices between two values\n * @param {number} from\n * @param {number} to\n * @returns {Array}\n */\nMatrix.indices = function indices(from, to) {\n    var vector = new Array(to - from);\n    for (var i = 0; i < vector.length; i++)\n        vector[i] = from++;\n    return vector;\n};\n\n// TODO DOC\nMatrix.stack = function stack(arg1) {\n    var i, j, k;\n    if (Matrix.isMatrix(arg1)) {\n        var rows = 0,\n            cols = 0;\n        for (i = 0; i < arguments.length; i++) {\n            rows += arguments[i].rows;\n            if (arguments[i].columns > cols)\n                cols = arguments[i].columns;\n        }\n\n        var r = Matrix.zeros(rows, cols);\n        var c = 0;\n        for (i = 0; i < arguments.length; i++) {\n            var current = arguments[i];\n            for (j = 0; j < current.rows; j++) {\n                for (k = 0; k < current.columns; k++)\n                    r[c][k] = current[j][k];\n                c++;\n            }\n        }\n        return r;\n    }\n    else if (Array.isArray(arg1)) {\n        var matrix = Matrix.empty(arguments.length, arg1.length);\n        for (i = 0; i < arguments.length; i++)\n            matrix.setRow(i, arguments[i]);\n        return matrix;\n    }\n};\n\n// TODO DOC\nMatrix.expand = function expand(base, count) {\n    var expansion = [];\n    for (var i = 0; i < count.length; i++)\n        for (var j = 0; j < count[i]; j++)\n            expansion.push(base[i]);\n    return new Matrix(expansion);\n};\n\n/**\n * Check that the provided value is a Matrix and tries to instantiate one if not\n * @param value - The value to check\n * @returns {Matrix}\n * @throws {TypeError}\n */\nMatrix.checkMatrix = function checkMatrix(value) {\n    if (!value) {\n        throw new TypeError('Argument has to be a matrix');\n    }\n    if (value.klass !== 'Matrix') {\n        value = new Matrix(value);\n    }\n    return value;\n};\n\n/**\n * Returns true if the argument is a Matrix, false otherwise\n * @param value - The value to check\n * @returns {boolean}\n */\nMatrix.isMatrix = function isMatrix(value) {\n    return value ? value.klass === 'Matrix' : false;\n};\n\n/**\n * @property {string} - The name of this class.\n */\nObject.defineProperty(Matrix.prototype, 'klass', {\n    get: function klass() {\n        return 'Matrix';\n    }\n});\n\n/**\n * @property {number} - The number of elements in the matrix.\n */\nObject.defineProperty(Matrix.prototype, 'size', {\n    get: function size() {\n        return this.rows * this.columns;\n    }\n});\n\n/**\n * @private\n * Internal check that a row index is not out of bounds\n * @param {number} index\n */\nMatrix.prototype.checkRowIndex = function checkRowIndex(index) {\n    if (index < 0 || index > this.rows - 1)\n        throw new RangeError('Row index out of range.');\n};\n\n/**\n * @private\n * Internal check that a column index is not out of bounds\n * @param {number} index\n */\nMatrix.prototype.checkColumnIndex = function checkColumnIndex(index) {\n    if (index < 0 || index > this.columns - 1)\n        throw new RangeError('Column index out of range.');\n};\n\n/**\n * @private\n * Internal check that two matrices have the same dimensions\n * @param {Matrix} otherMatrix\n */\nMatrix.prototype.checkDimensions = function checkDimensions(otherMatrix) {\n    if ((this.rows !== otherMatrix.rows) || (this.columns !== otherMatrix.columns))\n        throw new RangeError('Matrices dimensions must be equal.');\n};\n\n/**\n * Applies a callback for each element of the matrix. The function is called in the matrix (this) context.\n * @param {function} callback - Function that will be called with two parameters : i (row) and j (column)\n * @returns {Matrix} this\n */\nMatrix.prototype.apply = function apply(callback) {\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            callback.call(this, i, j);\n        }\n    }\n    return this;\n};\n\n/**\n * Creates an exact and independent copy of the matrix\n * @returns {Matrix}\n */\nMatrix.prototype.clone = function clone() {\n    return new Matrix(this.to2DArray());\n};\n\n/**\n * Returns a new 1D array filled row by row with the matrix values\n * @returns {Array}\n */\nMatrix.prototype.to1DArray = function to1DArray() {\n    return Aconcat.apply([], this);\n};\n\n/**\n * Returns a 2D array containing a copy of the data\n * @returns {Array}\n */\nMatrix.prototype.to2DArray = function to2DArray() {\n    var l = this.rows, copy = new Array(l);\n    for (var i = 0; i < l; i++) {\n        copy[i] = slice(this[i]);\n    }\n    return copy;\n};\n\n/**\n * @returns {boolean} true if the matrix has one row\n */\nMatrix.prototype.isRowVector = function isRowVector() {\n    return this.rows === 1;\n};\n\n/**\n * @returns {boolean} true if the matrix has one column\n */\nMatrix.prototype.isColumnVector = function isColumnVector() {\n    return this.columns === 1;\n};\n\n/**\n * @returns {boolean} true if the matrix has one row or one column\n */\nMatrix.prototype.isVector = function isVector() {\n    return (this.rows === 1) || (this.columns === 1);\n};\n\n/**\n * @returns {boolean} true if the matrix has the same number of rows and columns\n */\nMatrix.prototype.isSquare = function isSquare() {\n    return this.rows === this.columns;\n};\n\n/**\n * @returns {boolean} true if the matrix is square and has the same values on both sides of the diagonal\n */\nMatrix.prototype.isSymmetric = function isSymmetric() {\n    if (this.isSquare()) {\n        var l = this.rows;\n        for (var i = 0; i < l; i++) {\n            for (var j = 0; j <= i; j++) {\n                if (this[i][j] !== this[j][i]) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    return false;\n};\n\n/**\n * Sets a given element of the matrix. mat.set(3,4,1) is equivalent to mat[3][4]=1\n * @param {number} rowIndex - Index of the row\n * @param {number} columnIndex - Index of the column\n * @param {number} value - The new value for the element\n * @returns {Matrix} this\n */\nMatrix.prototype.set = function set(rowIndex, columnIndex, value) {\n    this[rowIndex][columnIndex] = value;\n    return this;\n};\n\n/**\n * Returns the given element of the matrix. mat.get(3,4) is equivalent to matrix[3][4]\n * @param {number} rowIndex - Index of the row\n * @param {number} columnIndex - Index of the column\n * @returns {number}\n */\nMatrix.prototype.get = function get(rowIndex, columnIndex) {\n    return this[rowIndex][columnIndex];\n};\n\n/**\n * Fills the matrix with a given value. All elements will be set to this value.\n * @param {number} value - New value\n * @returns {Matrix} this\n */\nMatrix.prototype.fill = function fill(value) {\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] = value;\n        }\n    }\n    return this;\n};\n\n/**\n * Negates the matrix. All elements will be multiplied by (-1)\n * @returns {Matrix} this\n */\nMatrix.prototype.neg = function neg() {\n    return this.mulS(-1);\n};\n\n/**\n * Adds a scalar or values from another matrix (in place)\n * @param {number|Matrix} value\n * @returns {Matrix} this\n */\nMatrix.prototype.add = function add(value) {\n    if (typeof value === 'number')\n        return this.addS(value);\n    value = Matrix.checkMatrix(value);\n        return this.addM(value);\n};\n\n/**\n * Adds a scalar to each element of the matrix\n * @param {number} value\n * @returns {Matrix} this\n */\nMatrix.prototype.addS = function addS(value) {\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] += value;\n        }\n    }\n    return this;\n};\n\n/**\n * Adds the value of each element of matrix to the corresponding element of this\n * @param {Matrix} matrix\n * @returns {Matrix} this\n */\nMatrix.prototype.addM = function addM(matrix) {\n    this.checkDimensions(matrix);\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] += matrix[i][j];\n        }\n    }\n    return this;\n};\n\n/**\n * Subtracts a scalar or values from another matrix (in place)\n * @param {number|Matrix} value\n * @returns {Matrix} this\n */\nMatrix.prototype.sub = function sub(value) {\n    if (typeof value === 'number')\n        return this.subS(value);\n    value = Matrix.checkMatrix(value);\n        return this.subM(value);\n};\n\n/**\n * Subtracts a scalar from each element of the matrix\n * @param {number} value\n * @returns {Matrix} this\n */\nMatrix.prototype.subS = function subS(value) {\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] -= value;\n        }\n    }\n    return this;\n};\n\n/**\n * Subtracts the value of each element of matrix from the corresponding element of this\n * @param {Matrix} matrix\n * @returns {Matrix} this\n */\nMatrix.prototype.subM = function subM(matrix) {\n    this.checkDimensions(matrix);\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] -= matrix[i][j];\n        }\n    }\n    return this;\n};\n\n/**\n * Multiplies a scalar or values from another matrix (in place)\n * @param {number|Matrix} value\n * @returns {Matrix} this\n */\nMatrix.prototype.mul = function mul(value) {\n    if (typeof value === 'number')\n        return this.mulS(value);\n    value = Matrix.checkMatrix(value);\n        return this.mulM(value);\n};\n\n/**\n * Multiplies a scalar with each element of the matrix\n * @param {number} value\n * @returns {Matrix} this\n */\nMatrix.prototype.mulS = function mulS(value) {\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] *= value;\n        }\n    }\n    return this;\n};\n\n/**\n * Multiplies the value of each element of matrix with the corresponding element of this\n * @param {Matrix} matrix\n * @returns {Matrix} this\n */\nMatrix.prototype.mulM = function mulM(matrix) {\n    this.checkDimensions(matrix);\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] *= matrix[i][j];\n        }\n    }\n    return this;\n};\n\n/**\n * Divides by a scalar or values from another matrix (in place)\n * @param {number|Matrix} value\n * @returns {Matrix} this\n */\nMatrix.prototype.div = function div(value) {\n    if (typeof value === 'number')\n        return this.divS(value);\n    value = Matrix.checkMatrix(value);\n        return this.divM(value);\n};\n\n/**\n * Divides each element of the matrix by a scalar\n * @param {number} value\n * @returns {Matrix} this\n */\nMatrix.prototype.divS = function divS(value) {\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] /= value;\n        }\n    }\n    return this;\n};\n\n/**\n * Divides each element of this by the corresponding element of matrix\n * @param {Matrix} matrix\n * @returns {Matrix} this\n */\nMatrix.prototype.divM = function divM(matrix) {\n    this.checkDimensions(matrix);\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] /= matrix[i][j];\n        }\n    }\n    return this;\n};\n\n/**\n * Returns a new array from the given row index\n * @param {number} index - Row index\n * @returns {Array}\n */\nMatrix.prototype.getRow = function getRow(index) {\n    this.checkRowIndex(index);\n    return slice(this[index]);\n};\n\n/**\n * Returns a new row vector from the given row index\n * @param {number} index - Row index\n * @returns {Matrix}\n */\nMatrix.prototype.getRowVector = function getRowVector(index) {\n    return Matrix.rowVector(this.getRow(index));\n};\n\n/**\n * Sets a row at the given index\n * @param {number} index - Row index\n * @param {Array|Matrix} array - Array or vector\n * @returns {Matrix} this\n */\nMatrix.prototype.setRow = function setRow(index, array) {\n    this.checkRowIndex(index);\n    if (Matrix.isMatrix(array)) array = array.to1DArray();\n    if (array.length !== this.columns)\n        throw new RangeError('Invalid row size');\n    this[index] = slice(array);\n    return this;\n};\n\n/**\n * Removes a row from the given index\n * @param {number} index - Row index\n * @returns {Matrix} this\n */\nMatrix.prototype.removeRow = function removeRow(index) {\n    this.checkRowIndex(index);\n    if (this.rows === 1)\n        throw new RangeError('A matrix cannot have less than one row');\n    Asplice.call(this, index, 1);\n    this.rows -= 1;\n    return this;\n};\n\n/**\n * Adds a row at the given index\n * @param {number} [index = this.rows] - Row index\n * @param {Array|Matrix} array - Array or vector\n * @returns {Matrix} this\n */\nMatrix.prototype.addRow = function addRow(index, array) {\n    if (typeof array === 'undefined') {\n        array = index;\n        index = this.rows;\n    }\n    if (index < 0 || index > this.rows)\n        throw new RangeError('Row index out of range.');\n    if (Matrix.isMatrix(array)) array = array.to1DArray();\n    if (array.length !== this.columns)\n        throw new RangeError('Invalid row size');\n    Asplice.call(this, index, 0, slice(array));\n    this.rows += 1;\n    return this;\n};\n\n/**\n * Swaps two rows\n * @param {number} row1 - First row index\n * @param {number} row2 - Second row index\n * @returns {Matrix} this\n */\nMatrix.prototype.swapRows = function swapRows(row1, row2) {\n    this.checkRowIndex(row1);\n    this.checkRowIndex(row2);\n    var temp = this[row1];\n    this[row1] = this[row2];\n    this[row2] = temp;\n    return this;\n};\n\n/**\n * Returns a new array from the given column index\n * @param {number} index - Column index\n * @returns {Array}\n */\nMatrix.prototype.getColumn = function getColumn(index) {\n    this.checkColumnIndex(index);\n    var l = this.rows, column = new Array(l);\n    for (var i = 0; i < l; i++) {\n        column[i] = this[i][index];\n    }\n    return column;\n};\n\n/**\n * Returns a new column vector from the given column index\n * @param {number} index - Column index\n * @returns {Matrix}\n */\nMatrix.prototype.getColumnVector = function getColumnVector(index) {\n    return Matrix.columnVector(this.getColumn(index));\n};\n\n/**\n * Sets a column at the given index\n * @param {number} index - Column index\n * @param {Array|Matrix} array - Array or vector\n * @returns {Matrix} this\n */\nMatrix.prototype.setColumn = function setColumn(index, array) {\n    this.checkColumnIndex(index);\n    if (Matrix.isMatrix(array)) array = array.to1DArray();\n    var l = this.rows;\n    if (array.length !== l)\n        throw new RangeError('Invalid column size');\n    for (var i = 0; i < l; i++) {\n        this[i][index] = array[i];\n    }\n    return this;\n};\n\n/**\n * Removes a column from the given index\n * @param {number} index - Column index\n * @returns {Matrix} this\n */\nMatrix.prototype.removeColumn = function removeColumn(index) {\n    this.checkColumnIndex(index);\n    if (this.columns === 1)\n        throw new RangeError('A matrix cannot have less than one column');\n    for (var i = 0, ii = this.rows; i < ii; i++) {\n        this[i].splice(index, 1);\n    }\n    this.columns -= 1;\n    return this;\n};\n\n/**\n * Adds a column at the given index\n * @param {number} [index = this.columns] - Column index\n * @param {Array|Matrix} array - Array or vector\n * @returns {Matrix} this\n */\nMatrix.prototype.addColumn = function addColumn(index, array) {\n    if (typeof array === 'undefined') {\n        array = index;\n        index = this.columns;\n    }\n    if (index < 0 || index > this.columns)\n        throw new RangeError('Column index out of range.');\n    if (Matrix.isMatrix(array)) array = array.to1DArray();\n    var l = this.rows;\n    if (array.length !== l)\n        throw new RangeError('Invalid column size');\n    for (var i = 0; i < l; i++) {\n        this[i].splice(index, 0, array[i]);\n    }\n    this.columns += 1;\n    return this;\n};\n\n/**\n * Swaps two columns\n * @param {number} column1 - First column index\n * @param {number} column2 - Second column index\n * @returns {Matrix} this\n */\nMatrix.prototype.swapColumns = function swapColumns(column1, column2) {\n    this.checkRowIndex(column1);\n    this.checkRowIndex(column2);\n    var l = this.rows, temp, row;\n    for (var i = 0; i < l; i++) {\n        row = this[i];\n        temp = row[column1];\n        row[column1] = row[column2];\n        row[column2] = temp;\n    }\n    return this;\n};\n\n/**\n * @private\n * Internal check that the provided vector is an array with the right length\n * @param {Array|Matrix} vector\n * @returns {Array}\n * @throws {RangeError}\n */\nMatrix.prototype.checkRowVector = function checkRowVector(vector) {\n    if (Matrix.isMatrix(vector))\n        vector = vector.to1DArray();\n    if (vector.length !== this.columns)\n        throw new RangeError('vector size must be the same as the number of columns');\n    return vector;\n};\n\n/**\n * @private\n * Internal check that the provided vector is an array with the right length\n * @param {Array|Matrix} vector\n * @returns {Array}\n * @throws {RangeError}\n */\nMatrix.prototype.checkColumnVector = function checkColumnVector(vector) {\n    if (Matrix.isMatrix(vector))\n        vector = vector.to1DArray();\n    if (vector.length !== this.rows)\n        throw new RangeError('vector size must be the same as the number of rows');\n    return vector;\n};\n\n/**\n * Adds the values of a vector to each row\n * @param {Array|Matrix} vector - Array or vector\n * @returns {Matrix} this\n */\nMatrix.prototype.addRowVector = function addRowVector(vector) {\n    vector = this.checkRowVector(vector);\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] += vector[j];\n        }\n    }\n    return this;\n};\n\n/**\n * Subtracts the values of a vector from each row\n * @param {Array|Matrix} vector - Array or vector\n * @returns {Matrix} this\n */\nMatrix.prototype.subRowVector = function subRowVector(vector) {\n    vector = this.checkRowVector(vector);\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] -= vector[j];\n        }\n    }\n    return this;\n};\n\n/**\n * Multiplies the values of a vector with each row\n * @param {Array|Matrix} vector - Array or vector\n * @returns {Matrix} this\n */\nMatrix.prototype.mulRowVector = function mulRowVector(vector) {\n    vector = this.checkRowVector(vector);\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] *= vector[j];\n        }\n    }\n    return this;\n};\n\n/**\n * Divides the values of each row by those of a vector\n * @param {Array|Matrix} vector - Array or vector\n * @returns {Matrix} this\n */\nMatrix.prototype.divRowVector = function divRowVector(vector) {\n    vector = this.checkRowVector(vector);\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] /= vector[j];\n        }\n    }\n    return this;\n};\n\n/**\n * Adds the values of a vector to each column\n * @param {Array|Matrix} vector - Array or vector\n * @returns {Matrix} this\n */\nMatrix.prototype.addColumnVector = function addColumnVector(vector) {\n    vector = this.checkColumnVector(vector);\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] += vector[i];\n        }\n    }\n    return this;\n};\n\n/**\n * Subtracts the values of a vector from each column\n * @param {Array|Matrix} vector - Array or vector\n * @returns {Matrix} this\n */\nMatrix.prototype.subColumnVector = function subColumnVector(vector) {\n    vector = this.checkColumnVector(vector);\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] -= vector[i];\n        }\n    }\n    return this;\n};\n\n/**\n * Multiplies the values of a vector with each column\n * @param {Array|Matrix} vector - Array or vector\n * @returns {Matrix} this\n */\nMatrix.prototype.mulColumnVector = function mulColumnVector(vector) {\n    vector = this.checkColumnVector(vector);\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] *= vector[i];\n        }\n    }\n    return this;\n};\n\n/**\n * Divides the values of each column by those of a vector\n * @param {Array|Matrix} vector - Array or vector\n * @returns {Matrix} this\n */\nMatrix.prototype.divColumnVector = function divColumnVector(vector) {\n    vector = this.checkColumnVector(vector);\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] /= vector[i];\n        }\n    }\n    return this;\n};\n\n/**\n * Multiplies the values of a row with a scalar\n * @param {number} index - Row index\n * @param {number} value\n * @returns {Matrix} this\n */\nMatrix.prototype.mulRow = function mulRow(index, value) {\n    this.checkRowIndex(index);\n    var i = 0, l = this.columns;\n    for (; i < l; i++) {\n        this[index][i] *= value;\n    }\n    return this;\n};\n\n/**\n * Multiplies the values of a column with a scalar\n * @param {number} index - Column index\n * @param {number} value\n * @returns {Matrix} this\n */\nMatrix.prototype.mulColumn = function mulColumn(index, value) {\n    this.checkColumnIndex(index);\n    var i = 0, l = this.rows;\n    for (; i < l; i++) {\n        this[i][index] *= value;\n    }\n};\n\n/**\n * A matrix index\n * @typedef {Object} MatrixIndex\n * @property {number} row\n * @property {number} column\n */\n\n/**\n * Returns the maximum value of the matrix\n * @returns {number}\n */\nMatrix.prototype.max = function max() {\n    var v = -Infinity;\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            if (this[i][j] > v) {\n                v = this[i][j];\n            }\n        }\n    }\n    return v;\n};\n\n/**\n * Returns the index of the maximum value\n * @returns {MatrixIndex}\n */\nMatrix.prototype.maxIndex = function maxIndex() {\n    var v = -Infinity;\n    var idx = {};\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            if (this[i][j] > v) {\n                v = this[i][j];\n                idx.row = i;\n                idx.column = j;\n            }\n        }\n    }\n    return idx;\n};\n\n/**\n * Returns the minimum value of the matrix\n * @returns {number}\n */\nMatrix.prototype.min = function min() {\n    var v = Infinity;\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            if (this[i][j] < v) {\n                v = this[i][j];\n            }\n        }\n    }\n    return v;\n};\n\n/**\n * Returns the index of the minimum value\n * @returns {MatrixIndex}\n */\nMatrix.prototype.minIndex = function minIndex() {\n    var v = Infinity;\n    var idx = {};\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            if (this[i][j] < v) {\n                v = this[i][j];\n                idx.row = i;\n                idx.column = j;\n            }\n        }\n    }\n    return idx;\n};\n\n/**\n * Returns the maximum value of one row\n * @param {number} index - Row index\n * @returns {number}\n */\nMatrix.prototype.maxRow = function maxRow(index) {\n    this.checkRowIndex(index);\n    var v = -Infinity;\n    for (var i = 0, ii = this.columns; i < ii; i++) {\n        if (this[index][i] > v) {\n            v = this[index][i];\n        }\n    }\n    return v;\n};\n\n/**\n * Returns the index of the maximum value of one row\n * @param {number} index - Row index\n * @returns {MatrixIndex}\n */\nMatrix.prototype.maxRowIndex = function maxRowIndex(index) {\n    this.checkRowIndex(index);\n    var v = -Infinity;\n    var idx = {\n            row: index\n        };\n    for (var i = 0, ii = this.columns; i < ii; i++) {\n        if (this[index][i] > v) {\n            v = this[index][i];\n            idx.column = i;\n        }\n    }\n    return idx;\n};\n\n/**\n * Returns the minimum value of one row\n * @param {number} index - Row index\n * @returns {number}\n */\nMatrix.prototype.minRow = function minRow(index) {\n    this.checkRowIndex(index);\n    var v = Infinity;\n    for (var i = 0, ii = this.columns; i < ii; i++) {\n        if (this[index][i] < v) {\n            v = this[index][i];\n        }\n    }\n    return v;\n};\n\n/**\n * Returns the index of the maximum value of one row\n * @param {number} index - Row index\n * @returns {MatrixIndex}\n */\nMatrix.prototype.minRowIndex = function minRowIndex(index) {\n    this.checkRowIndex(index);\n    var v = Infinity;\n    var idx = {\n        row: index,\n        column: 0\n    };\n    for (var i = 0, ii = this.columns; i < ii; i++) {\n        if (this[index][i] < v) {\n            v = this[index][i];\n            idx.column = i;\n        }\n    }\n    return idx;\n};\n\n/**\n * Returns the maximum value of one column\n * @param {number} index - Column index\n * @returns {number}\n */\nMatrix.prototype.maxColumn = function maxColumn(index) {\n    this.checkColumnIndex(index);\n    var v = -Infinity;\n    for (var i = 0, ii = this.rows; i < ii; i++) {\n        if (this[i][index] > v) {\n            v = this[i][index];\n        }\n    }\n    return v;\n};\n\n/**\n * Returns the index of the maximum value of one column\n * @param {number} index - Column index\n * @returns {MatrixIndex}\n */\nMatrix.prototype.maxColumnIndex = function maxColumnIndex(index) {\n    this.checkColumnIndex(index);\n    var v = -Infinity;\n    var idx = {\n        row: 0,\n        column: index\n    };\n    for (var i = 0, ii = this.rows; i < ii; i++) {\n        if (this[i][index] > v) {\n            v = this[i][index];\n            idx.row = i;\n        }\n    }\n    return idx;\n};\n\n/**\n * Returns the minimum value of one column\n * @param {number} index - Column index\n * @returns {number}\n */\nMatrix.prototype.minColumn = function minColumn(index) {\n    this.checkColumnIndex(index);\n    var v = Infinity;\n    for (var i = 0, ii = this.rows; i < ii; i++) {\n        if (this[i][index] < v) {\n            v = this[i][index];\n        }\n    }\n    return v;\n};\n\n/**\n * Returns the index of the minimum value of one column\n * @param {number} index - Column index\n * @returns {MatrixIndex}\n */\nMatrix.prototype.minColumnIndex = function minColumnIndex(index) {\n    this.checkColumnIndex(index);\n    var v = Infinity;\n    var idx = {\n        row: 0,\n        column: index\n    };\n    for (var i = 0, ii = this.rows; i < ii; i++) {\n        if (this[i][index] < v) {\n            v = this[i][index];\n            idx.row = i;\n        }\n    }\n    return idx;\n};\n\n/**\n * Returns an array containing the diagonal values of the matrix\n * @returns {Array}\n */\nMatrix.prototype.diag = function diag() {\n    if (!this.isSquare())\n        throw new TypeError('Only square matrices have a diagonal.');\n    var diag = new Array(this.rows);\n    for (var i = 0, ii = this.rows; i < ii; i++) {\n        diag[i] = this[i][i];\n    }\n    return diag;\n};\n\n/**\n * Returns the sum of all elements of the matrix\n * @returns {number}\n */\nMatrix.prototype.sum = function sum() {\n    var v = 0;\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            v += this[i][j];\n        }\n    }\n    return v;\n};\n\n/**\n * Returns the mean of all elements of the matrix\n * @returns {number}\n */\nMatrix.prototype.mean = function mean() {\n    return this.sum() / this.size;\n};\n\n/**\n * Returns the product of all elements of the matrix\n * @returns {number}\n */\nMatrix.prototype.prod = function prod() {\n    var prod = 1;\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            prod *= this[i][j];\n        }\n    }\n    return prod;\n};\n\n/**\n * Computes the cumulative sum of the matrix elements (in place, row by row)\n * @returns {Matrix} this\n */\nMatrix.prototype.cumulativeSum = function cumulativeSum() {\n    var sum = 0;\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            sum += this[i][j];\n            this[i][j] = sum;\n        }\n    }\n    return this;\n};\n\n/**\n * Computes the dot (scalar) product between the matrix and another\n * @param {Matrix} other vector\n * @returns {number}\n */\nMatrix.prototype.dot = function dot(other) {\n    if (this.size !== other.size)\n        throw new RangeError('vectors do not have the same size');\n    var vector1 = this.to1DArray();\n    var vector2 = other.to1DArray();\n    var dot = 0, l = vector1.length;\n    for (var i = 0; i < l; i++) {\n        dot += vector1[i] * vector2[i];\n    }\n    return dot;\n};\n\n/**\n * Returns the matrix product between this and other\n * @returns {Matrix}\n */\nMatrix.prototype.mmul = function mmul(other) {\n    if (!Matrix.isMatrix(other))\n        throw new TypeError('parameter \"other\" must be a matrix');\n    if (this.columns !== other.rows)\n        console.warn('Number of columns of left matrix are not equal to number of rows of right matrix.');\n\n    var m = this.rows, n = this.columns, p = other.columns;\n    var result = new Matrix(m, p);\n\n    var Bcolj = new Array(n);\n    var i, j, k;\n    for (j = 0; j < p; j++) {\n        for (k = 0; k < n; k++)\n            Bcolj[k] = other[k][j];\n\n        for (i = 0; i < m; i++) {\n            var Arowi = this[i];\n\n            var s = 0;\n            for (k = 0; k < n; k++)\n                s += Arowi[k] * Bcolj[k];\n\n            result[i][j] = s;\n        }\n    }\n    return result;\n};\n\n/**\n * Sorts the rows (in place)\n * @param {function} compareFunction - usual Array.prototype.sort comparison function\n * @returns {Matrix} this\n */\nMatrix.prototype.sortRows = function sortRows(compareFunction) {\n    for (var i = 0, ii = this.rows; i < ii; i++) {\n        this[i].sort(compareFunction);\n    }\n    return this;\n};\n\n/**\n * Sorts the columns (in place)\n * @param {function} compareFunction - usual Array.prototype.sort comparison function\n * @returns {Matrix} this\n */\nMatrix.prototype.sortColumns = function sortColumns(compareFunction) {\n    for (var i = 0, ii = this.columns; i < ii; i++) {\n        this.setColumn(i, this.getColumn(i).sort(compareFunction));\n    }\n    return this;\n};\n\n/**\n * Transposes the matrix and returns a new one containing the result\n * @returns {Matrix}\n */\nMatrix.prototype.transpose = function transpose() {\n    var result = new Matrix(this.columns, this.rows);\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            result[j][i] = this[i][j];\n        }\n    }\n    return result;\n};\n\n/**\n * Returns a subset of the matrix\n * @param {number} startRow - First row index\n * @param {number} endRow - Last row index\n * @param {number} startColumn - First column index\n * @param {number} endColumn - Last column index\n * @returns {Matrix}\n */\nMatrix.prototype.subMatrix = function subMatrix(startRow, endRow, startColumn, endColumn) {\n    if ((startRow > endRow) || (startColumn > endColumn) || (startRow < 0) || (startRow >= this.rows) || (endRow < 0) || (endRow >= this.rows) || (startColumn < 0) || (startColumn >= this.columns) || (endColumn < 0) || (endColumn >= this.columns))\n        throw new RangeError('Argument out of range');\n    var newMatrix = new Matrix(endRow - startRow + 1, endColumn - startColumn + 1);\n    for (var i = startRow; i <= endRow; i++) {\n        for (var j = startColumn; j <= endColumn; j++) {\n            newMatrix[i - startRow][j - startColumn] = this[i][j];\n        }\n    }\n    return newMatrix;\n};\n\n/**\n * Returns a subset of the matrix based on an array of row indices\n * @param {Array} indices - Array containing the row indices\n * @param {number} [startColumn = 0] - First column index\n * @param {number} [endColumn = this.columns-1] - Last column index\n * @returns {Matrix}\n */\nMatrix.prototype.subMatrixRow = function subMatrixRow(indices, startColumn, endColumn) {\n    if (typeof startColumn === 'undefined') {\n        startColumn = 0;\n        endColumn = this.columns - 1;\n    } else if (typeof endColumn === 'undefined') {\n        endColumn = this.columns - 1;\n    }\n    if ((startColumn > endColumn) || (startColumn < 0) || (startColumn >= this.columns) || (endColumn < 0) || (endColumn >= this.columns))\n        throw new RangeError('Argument out of range.');\n    var l = indices.length, rows = this.rows,\n        X = new Matrix(l, endColumn - startColumn + 1);\n    for (var i = 0; i < l; i++) {\n        for (var j = startColumn; j <= endColumn; j++) {\n            if ((indices[i] < 0) || (indices[i] >= rows))\n                throw new RangeError('Argument out of range.');\n            X[i][j - startColumn] = this[indices[i]][j];\n        }\n    }\n    return X;\n};\n\n/**\n * Returns a subset of the matrix based on an array of column indices\n * @param {Array} indices - Array containing the column indices\n * @param {number} [startRow = 0] - First row index\n * @param {number} [endRow = this.rows-1] - Last row index\n * @returns {Matrix}\n */\nMatrix.prototype.subMatrixColumn = function subMatrixColumn(indices, startRow, endRow) {\n    if (typeof startRow === 'undefined') {\n        startRow = 0;\n        endRow = this.rows - 1;\n    } else if (typeof endRow === 'undefined') {\n        endRow = this.rows - 1;\n    }\n    if ((startRow > endRow) || (startRow < 0) || (startRow >= this.rows) || (endRow < 0) || (endRow >= this.rows))\n        throw new RangeError('Argument out of range.');\n    var l = indices.length, columns = this.columns,\n        X = new Matrix(endRow - startRow + 1, l);\n    for (var i = 0; i < l; i++) {\n        for (var j = startRow; j <= endRow; j++) {\n            if ((indices[i] < 0) || (indices[i] >= columns))\n                throw new RangeError('Argument out of range.');\n            X[j - startRow][i] = this[j][indices[i]];\n        }\n    }\n    return X;\n};\n\n/**\n * Returns the trace of the matrix (sum of the diagonal elements)\n * @returns {number}\n */\nMatrix.prototype.trace = function trace() {\n    if (!this.isSquare())\n        throw new TypeError('The matrix is not square');\n    var trace = 0, i = 0, l = this.rows;\n    for (; i < l; i++) {\n        trace += this[i][i];\n    }\n    return trace;\n};\n\n/**\n * Sets each element of the matrix to its absolute value\n * @returns {Matrix} this\n */\nMatrix.prototype.abs = function abs() {\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] = Math.abs(this[i][j]);\n        }\n    }\n};\n\nmodule.exports = Matrix;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ml-matrix/src/matrix.js\n ** module id = 4\n ** module chunks = 0\n **/","'use strict';\n\nvar Matrix = require('./matrix');\n\nvar SingularValueDecomposition = require('./dc/svd');\nvar EigenvalueDecomposition = require('./dc/evd');\nvar LuDecomposition = require('./dc/lu');\nvar QrDecomposition = require('./dc/qr');\nvar CholeskyDecomposition = require('./dc/cholesky');\n\nfunction inverse(matrix) {\n    return solve(matrix, Matrix.eye(matrix.rows));\n}\n\nMatrix.prototype.inverse = function () {\n    return inverse(this);\n};\n\nfunction solve(leftHandSide, rightHandSide) {\n    return leftHandSide.isSquare() ? new LuDecomposition(leftHandSide).solve(rightHandSide) : new QrDecomposition(leftHandSide).solve(rightHandSide);\n}\n\nMatrix.prototype.solve = function (other) {\n    return solve(this, other);\n};\n\nmodule.exports = {\n    SingularValueDecomposition: SingularValueDecomposition,\n    SVD: SingularValueDecomposition,\n    EigenvalueDecomposition: EigenvalueDecomposition,\n    EVD: EigenvalueDecomposition,\n    LuDecomposition: LuDecomposition,\n    LU: LuDecomposition,\n    QrDecomposition: QrDecomposition,\n    QR: QrDecomposition,\n    CholeskyDecomposition: CholeskyDecomposition,\n    CHO: CholeskyDecomposition,\n    inverse: inverse,\n    solve: solve\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ml-matrix/src/decompositions.js\n ** module id = 5\n ** module chunks = 0\n **/","'use strict';\n\nvar Matrix = require('../matrix');\nvar hypotenuse = require('./util').hypotenuse;\n\n// https://github.com/lutzroeder/Mapack/blob/master/Source/SingularValueDecomposition.cs\nfunction SingularValueDecomposition(value, options) {\n    if (!(this instanceof SingularValueDecomposition)) {\n        return new SingularValueDecomposition(value, options);\n    }\n    value = Matrix.checkMatrix(value);\n\n    options = options || {};\n\n    var a = value.clone(),\n        m = value.rows,\n        n = value.columns,\n        nu = Math.min(m, n);\n\n    var wantu = true, wantv = true;\n    if (options.computeLeftSingularVectors === false)\n        wantu = false;\n    if (options.computeRightSingularVectors === false)\n        wantv = false;\n    var autoTranspose = options.autoTranspose === true;\n\n    var swapped = false;\n    if (m < n) {\n        if (!autoTranspose) {\n            console.warn('Computing SVD on a matrix with more columns than rows. Consider enabling autoTranspose');\n        } else {\n            a = a.transpose();\n            m = a.rows;\n            n = a.columns;\n            swapped = true;\n            var aux = wantu;\n            wantu = wantv;\n            wantv = aux;\n        }\n    }\n\n    var s = new Array(Math.min(m + 1, n)),\n        U = Matrix.zeros(m, nu),\n        V = Matrix.zeros(n, n),\n        e = new Array(n),\n        work = new Array(m);\n\n    var nct = Math.min(m - 1, n);\n    var nrt = Math.max(0, Math.min(n - 2, m));\n\n    var i, j, k, p, t, ks, f, cs, sn, max, kase,\n        scale, sp, spm1, epm1, sk, ek, b, c, shift, g;\n\n    for (k = 0, max = Math.max(nct, nrt); k < max; k++) {\n        if (k < nct) {\n            s[k] = 0;\n            for (i = k; i < m; i++) {\n                s[k] = hypotenuse(s[k], a[i][k]);\n            }\n            if (s[k] !== 0) {\n                if (a[k][k] < 0) {\n                    s[k] = -s[k];\n                }\n                for (i = k; i < m; i++) {\n                    a[i][k] /= s[k];\n                }\n                a[k][k] += 1;\n            }\n            s[k] = -s[k];\n        }\n\n        for (j = k + 1; j < n; j++) {\n            if ((k < nct) && (s[k] !== 0)) {\n                t = 0;\n                for (i = k; i < m; i++) {\n                    t += a[i][k] * a[i][j];\n                }\n                t = -t / a[k][k];\n                for (i = k; i < m; i++) {\n                    a[i][j] += t * a[i][k];\n                }\n            }\n            e[j] = a[k][j];\n        }\n\n        if (wantu && (k < nct)) {\n            for (i = k; i < m; i++) {\n                U[i][k] = a[i][k];\n            }\n        }\n\n        if (k < nrt) {\n            e[k] = 0;\n            for (i = k + 1; i < n; i++) {\n                e[k] = hypotenuse(e[k], e[i]);\n            }\n            if (e[k] !== 0) {\n                if (e[k + 1] < 0)\n                    e[k] = -e[k];\n                for (i = k + 1; i < n; i++) {\n                    e[i] /= e[k];\n                }\n                e[k + 1] += 1;\n            }\n            e[k] = -e[k];\n            if ((k + 1 < m) && (e[k] !== 0)) {\n                for (i = k + 1; i < m; i++) {\n                    work[i] = 0;\n                }\n                for (j = k + 1; j < n; j++) {\n                    for (i = k + 1; i < m; i++) {\n                        work[i] += e[j] * a[i][j];\n                    }\n                }\n                for (j = k + 1; j < n; j++) {\n                    t = -e[j] / e[k + 1];\n                    for (i = k + 1; i < m; i++) {\n                        a[i][j] += t * work[i];\n                    }\n                }\n            }\n            if (wantv) {\n                for (i = k + 1; i < n; i++) {\n                    V[i][k] = e[i];\n                }\n            }\n        }\n    }\n\n    p = Math.min(n, m + 1);\n    if (nct < n) {\n        s[nct] = a[nct][nct];\n    }\n    if (m < p) {\n        s[p - 1] = 0;\n    }\n    if (nrt + 1 < p) {\n        e[nrt] = a[nrt][p - 1];\n    }\n    e[p - 1] = 0;\n\n    if (wantu) {\n        for (j = nct; j < nu; j++) {\n            for (i = 0; i < m; i++) {\n                U[i][j] = 0;\n            }\n            U[j][j] = 1;\n        }\n        for (k = nct - 1; k >= 0; k--) {\n            if (s[k] !== 0) {\n                for (j = k + 1; j < nu; j++) {\n                    t = 0;\n                    for (i = k; i < m; i++) {\n                        t += U[i][k] * U[i][j];\n                    }\n                    t = -t / U[k][k];\n                    for (i = k; i < m; i++) {\n                        U[i][j] += t * U[i][k];\n                    }\n                }\n                for (i = k; i < m; i++) {\n                    U[i][k] = -U[i][k];\n                }\n                U[k][k] = 1 + U[k][k];\n                for (i = 0; i < k - 1; i++) {\n                    U[i][k] = 0;\n                }\n            } else {\n                for (i = 0; i < m; i++) {\n                    U[i][k] = 0;\n                }\n                U[k][k] = 1;\n            }\n        }\n    }\n\n    if (wantv) {\n        for (k = n - 1; k >= 0; k--) {\n            if ((k < nrt) && (e[k] !== 0)) {\n                for (j = k + 1; j < n; j++) {\n                    t = 0;\n                    for (i = k + 1; i < n; i++) {\n                        t += V[i][k] * V[i][j];\n                    }\n                    t = -t / V[k + 1][k];\n                    for (i = k + 1; i < n; i++) {\n                        V[i][j] += t * V[i][k];\n                    }\n                }\n            }\n            for (i = 0; i < n; i++) {\n                V[i][k] = 0;\n            }\n            V[k][k] = 1;\n        }\n    }\n\n    var pp = p - 1,\n        iter = 0,\n        eps = Math.pow(2, -52);\n    while (p > 0) {\n        for (k = p - 2; k >= -1; k--) {\n            if (k === -1) {\n                break;\n            }\n            if (Math.abs(e[k]) <= eps * (Math.abs(s[k]) + Math.abs(s[k + 1]))) {\n                e[k] = 0;\n                break;\n            }\n        }\n        if (k === p - 2) {\n            kase = 4;\n        } else {\n            for (ks = p - 1; ks >= k; ks--) {\n                if (ks === k) {\n                    break;\n                }\n                t = (ks !== p ? Math.abs(e[ks]) : 0) + (ks !== k + 1 ? Math.abs(e[ks - 1]) : 0);\n                if (Math.abs(s[ks]) <= eps * t) {\n                    s[ks] = 0;\n                    break;\n                }\n            }\n            if (ks === k) {\n                kase = 3;\n            } else if (ks === p - 1) {\n                kase = 1;\n            } else {\n                kase = 2;\n                k = ks;\n            }\n        }\n\n        k++;\n\n        switch (kase) {\n            case 1: {\n                f = e[p - 2];\n                e[p - 2] = 0;\n                for (j = p - 2; j >= k; j--) {\n                    t = hypotenuse(s[j], f);\n                    cs = s[j] / t;\n                    sn = f / t;\n                    s[j] = t;\n                    if (j !== k) {\n                        f = -sn * e[j - 1];\n                        e[j - 1] = cs * e[j - 1];\n                    }\n                    if (wantv) {\n                        for (i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][p - 1];\n                            V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n                            V[i][j] = t;\n                        }\n                    }\n                }\n                break;\n            }\n            case 2 : {\n                f = e[k - 1];\n                e[k - 1] = 0;\n                for (j = k; j < p; j++) {\n                    t = hypotenuse(s[j], f);\n                    cs = s[j] / t;\n                    sn = f / t;\n                    s[j] = t;\n                    f = -sn * e[j];\n                    e[j] = cs * e[j];\n                    if (wantu) {\n                        for (i = 0; i < m; i++) {\n                            t = cs * U[i][j] + sn * U[i][k - 1];\n                            U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n                            U[i][j] = t;\n                        }\n                    }\n                }\n                break;\n            }\n            case 3 : {\n                scale = Math.max(Math.max(Math.max(Math.max(Math.abs(s[p - 1]), Math.abs(s[p - 2])), Math.abs(e[p - 2])), Math.abs(s[k])), Math.abs(e[k]));\n                sp = s[p - 1] / scale;\n                spm1 = s[p - 2] / scale;\n                epm1 = e[p - 2] / scale;\n                sk = s[k] / scale;\n                ek = e[k] / scale;\n                b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2;\n                c = (sp * epm1) * (sp * epm1);\n                shift = 0;\n                if ((b !== 0) || (c !== 0)) {\n                    shift = Math.sqrt(b * b + c);\n                    if (b < 0) {\n                        shift = -shift;\n                    }\n                    shift = c / (b + shift);\n                }\n                f = (sk + sp) * (sk - sp) + shift;\n                g = sk * ek;\n                for (j = k; j < p - 1; j++) {\n                    t = hypotenuse(f, g);\n                    cs = f / t;\n                    sn = g / t;\n                    if (j !== k) {\n                        e[j - 1] = t;\n                    }\n                    f = cs * s[j] + sn * e[j];\n                    e[j] = cs * e[j] - sn * s[j];\n                    g = sn * s[j + 1];\n                    s[j + 1] = cs * s[j + 1];\n                    if (wantv) {\n                        for (i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][j + 1];\n                            V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n                            V[i][j] = t;\n                        }\n                    }\n                    t = hypotenuse(f, g);\n                    cs = f / t;\n                    sn = g / t;\n                    s[j] = t;\n                    f = cs * e[j] + sn * s[j + 1];\n                    s[j + 1] = -sn * e[j] + cs * s[j + 1];\n                    g = sn * e[j + 1];\n                    e[j + 1] = cs * e[j + 1];\n                    if (wantu && (j < m - 1)) {\n                        for (i = 0; i < m; i++) {\n                            t = cs * U[i][j] + sn * U[i][j + 1];\n                            U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n                            U[i][j] = t;\n                        }\n                    }\n                }\n                e[p - 2] = f;\n                iter = iter + 1;\n                break;\n            }\n            case 4: {\n                if (s[k] <= 0) {\n                    s[k] = (s[k] < 0 ? -s[k] : 0);\n                    if (wantv) {\n                        for (i = 0; i <= pp; i++) {\n                            V[i][k] = -V[i][k];\n                        }\n                    }\n                }\n                while (k < pp) {\n                    if (s[k] >= s[k + 1]) {\n                        break;\n                    }\n                    t = s[k];\n                    s[k] = s[k + 1];\n                    s[k + 1] = t;\n                    if (wantv && (k < n - 1)) {\n                        for (i = 0; i < n; i++) {\n                            t = V[i][k + 1];\n                            V[i][k + 1] = V[i][k];\n                            V[i][k] = t;\n                        }\n                    }\n                    if (wantu && (k < m - 1)) {\n                        for (i = 0; i < m; i++) {\n                            t = U[i][k + 1];\n                            U[i][k + 1] = U[i][k];\n                            U[i][k] = t;\n                        }\n                    }\n                    k++;\n                }\n                iter = 0;\n                p--;\n                break;\n            }\n        }\n    }\n\n    if (swapped) {\n        var tmp = V;\n        V = U;\n        U = tmp;\n    }\n\n    this.m = m;\n    this.n = n;\n    this.s = s;\n    this.U = U;\n    this.V = V;\n}\n\nSingularValueDecomposition.prototype = {\n    get condition() {\n        return this.s[0] / this.s[Math.min(this.m, this.n) - 1];\n    },\n    get norm2() {\n        return this.s[0];\n    },\n    get rank() {\n        var eps = Math.pow(2, -52),\n            tol = Math.max(this.m, this.n) * this.s[0] * eps,\n            r = 0,\n            s = this.s;\n        for (var i = 0, ii = s.length; i < ii; i++) {\n            if (s[i] > tol) {\n                r++;\n            }\n        }\n        return r;\n    },\n    get diagonal() {\n        return this.s;\n    },\n    // https://github.com/accord-net/framework/blob/development/Sources/Accord.Math/Decompositions/SingularValueDecomposition.cs\n    get threshold() {\n        return (Math.pow(2, -52) / 2) * Math.max(this.m, this.n) * this.s[0];\n    },\n    get leftSingularVectors() {\n        return this.U;\n    },\n    get rightSingularVectors() {\n        return this.V;\n    },\n    get diagonalMatrix() {\n        return Matrix.diag(this.s);\n    },\n    solve: function (value) {\n\n        var Y = value,\n            e = this.threshold,\n            scols = this.s.length,\n            Ls = Matrix.zeros(scols, scols),\n            i;\n\n        for (i = 0; i < scols; i++) {\n            if (Math.abs(this.s[i]) <= e) {\n                Ls[i][i] = 0;\n            } else {\n                Ls[i][i] = 1 / this.s[i];\n            }\n        }\n\n\n        var VL = this.V.mmul(Ls),\n            vrows = this.V.rows,\n            urows = this.U.rows,\n            VLU = Matrix.zeros(vrows, urows),\n            j, k, sum;\n\n        for (i = 0; i < vrows; i++) {\n            for (j = 0; j < urows; j++) {\n                sum = 0;\n                for (k = 0; k < scols; k++) {\n                    sum += VL[i][k] * this.U[j][k];\n                }\n                VLU[i][j] = sum;\n            }\n        }\n\n        return VLU.mmul(Y);\n    },\n    solveForDiagonal: function (value) {\n        return this.solve(Matrix.diag(value));\n    },\n    inverse: function () {\n        var e = this.threshold,\n            vrows = this.V.rows,\n            vcols = this.V.columns,\n            X = new Matrix(vrows, this.s.length),\n            i, j;\n\n        for (i = 0; i < vrows; i++) {\n            for (j = 0; j < vcols; j++) {\n                if (Math.abs(this.s[j]) > e) {\n                    X[i][j] = this.V[i][j] / this.s[j];\n                } else {\n                    X[i][j] = 0;\n                }\n            }\n        }\n\n        var urows = this.U.rows,\n            ucols = this.U.columns,\n            Y = new Matrix(vrows, urows),\n            k, sum;\n\n        for (i = 0; i < vrows; i++) {\n            for (j = 0; j < urows; j++) {\n                sum = 0;\n                for (k = 0; k < ucols; k++) {\n                    sum += X[i][k] * this.U[j][k];\n                }\n                Y[i][j] = sum;\n            }\n        }\n\n        return Y;\n    }\n};\n\nmodule.exports = SingularValueDecomposition;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ml-matrix/src/dc/svd.js\n ** module id = 6\n ** module chunks = 0\n **/","'use strict';\n\nexports.hypotenuse = function hypotenuse(a, b) {\n    var r;\n    if (Math.abs(a) > Math.abs(b)) {\n        r = b / a;\n        return Math.abs(a) * Math.sqrt(1 + r * r);\n    }\n    if (b !== 0) {\n        r = a / b;\n        return Math.abs(b) * Math.sqrt(1 + r * r);\n    }\n    return 0;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ml-matrix/src/dc/util.js\n ** module id = 7\n ** module chunks = 0\n **/","'use strict';\n\nvar Matrix = require('../matrix');\nvar hypotenuse = require('./util').hypotenuse;\n\n// https://github.com/lutzroeder/Mapack/blob/master/Source/EigenvalueDecomposition.cs\nfunction EigenvalueDecomposition(matrix) {\n    if (!(this instanceof EigenvalueDecomposition)) {\n        return new EigenvalueDecomposition(matrix);\n    }\n    matrix = Matrix.checkMatrix(matrix);\n    if (!matrix.isSquare()) {\n        throw new Error('Matrix is not a square matrix');\n    }\n\n    var n = matrix.columns,\n        V = Matrix.zeros(n, n),\n        d = new Array(n),\n        e = new Array(n),\n        value = matrix,\n        i, j;\n\n    if (matrix.isSymmetric()) {\n        for (i = 0; i < n; i++) {\n            for (j = 0; j < n; j++) {\n                V[i][j] = value[i][j];\n            }\n        }\n        tred2(n, e, d, V);\n        tql2(n, e, d, V);\n    }\n    else {\n        var H = Matrix.zeros(n, n),\n            ort = new Array(n);\n        for (j = 0; j < n; j++) {\n            for (i = 0; i < n; i++) {\n                H[i][j] = value[i][j];\n            }\n        }\n        orthes(n, H, ort, V);\n        hqr2(n, e, d, V, H);\n    }\n\n    this.n = n;\n    this.e = e;\n    this.d = d;\n    this.V = V;\n}\n\nEigenvalueDecomposition.prototype = {\n    get realEigenvalues() {\n        return this.d;\n    },\n    get imaginaryEigenvalues() {\n        return this.e;\n    },\n    get eigenvectorMatrix() {\n        return this.V;\n    },\n    get diagonalMatrix() {\n        var n = this.n,\n            e = this.e,\n            d = this.d,\n            X = new Matrix(n, n),\n            i, j;\n        for (i = 0; i < n; i++) {\n            for (j = 0; j < n; j++) {\n                X[i][j] = 0;\n            }\n            X[i][i] = d[i];\n            if (e[i] > 0) {\n                X[i][i + 1] = e[i];\n            }\n            else if (e[i] < 0) {\n                X[i][i - 1] = e[i];\n            }\n        }\n        return X;\n    }\n};\n\nfunction tred2(n, e, d, V) {\n\n    var f, g, h, i, j, k,\n        hh, scale;\n\n    for (j = 0; j < n; j++) {\n        d[j] = V[n - 1][j];\n    }\n\n    for (i = n - 1; i > 0; i--) {\n        scale = 0;\n        h = 0;\n        for (k = 0; k < i; k++) {\n            scale = scale + Math.abs(d[k]);\n        }\n\n        if (scale === 0) {\n            e[i] = d[i - 1];\n            for (j = 0; j < i; j++) {\n                d[j] = V[i - 1][j];\n                V[i][j] = 0;\n                V[j][i] = 0;\n            }\n        } else {\n            for (k = 0; k < i; k++) {\n                d[k] /= scale;\n                h += d[k] * d[k];\n            }\n\n            f = d[i - 1];\n            g = Math.sqrt(h);\n            if (f > 0) {\n                g = -g;\n            }\n\n            e[i] = scale * g;\n            h = h - f * g;\n            d[i - 1] = f - g;\n            for (j = 0; j < i; j++) {\n                e[j] = 0;\n            }\n\n            for (j = 0; j < i; j++) {\n                f = d[j];\n                V[j][i] = f;\n                g = e[j] + V[j][j] * f;\n                for (k = j + 1; k <= i - 1; k++) {\n                    g += V[k][j] * d[k];\n                    e[k] += V[k][j] * f;\n                }\n                e[j] = g;\n            }\n\n            f = 0;\n            for (j = 0; j < i; j++) {\n                e[j] /= h;\n                f += e[j] * d[j];\n            }\n\n            hh = f / (h + h);\n            for (j = 0; j < i; j++) {\n                e[j] -= hh * d[j];\n            }\n\n            for (j = 0; j < i; j++) {\n                f = d[j];\n                g = e[j];\n                for (k = j; k <= i - 1; k++) {\n                    V[k][j] -= (f * e[k] + g * d[k]);\n                }\n                d[j] = V[i - 1][j];\n                V[i][j] = 0;\n            }\n        }\n        d[i] = h;\n    }\n\n    for (i = 0; i < n - 1; i++) {\n        V[n - 1][i] = V[i][i];\n        V[i][i] = 1;\n        h = d[i + 1];\n        if (h !== 0) {\n            for (k = 0; k <= i; k++) {\n                d[k] = V[k][i + 1] / h;\n            }\n\n            for (j = 0; j <= i; j++) {\n                g = 0;\n                for (k = 0; k <= i; k++) {\n                    g += V[k][i + 1] * V[k][j];\n                }\n                for (k = 0; k <= i; k++) {\n                    V[k][j] -= g * d[k];\n                }\n            }\n        }\n\n        for (k = 0; k <= i; k++) {\n            V[k][i + 1] = 0;\n        }\n    }\n\n    for (j = 0; j < n; j++) {\n        d[j] = V[n - 1][j];\n        V[n - 1][j] = 0;\n    }\n\n    V[n - 1][n - 1] = 1;\n    e[0] = 0;\n}\n\nfunction tql2(n, e, d, V) {\n\n    var g, h, i, j, k, l, m, p, r,\n        dl1, c, c2, c3, el1, s, s2,\n        iter;\n\n    for (i = 1; i < n; i++) {\n        e[i - 1] = e[i];\n    }\n\n    e[n - 1] = 0;\n\n    var f = 0,\n        tst1 = 0,\n        eps = Math.pow(2, -52);\n\n    for (l = 0; l < n; l++) {\n        tst1 = Math.max(tst1, Math.abs(d[l]) + Math.abs(e[l]));\n        m = l;\n        while (m < n) {\n            if (Math.abs(e[m]) <= eps * tst1) {\n                break;\n            }\n            m++;\n        }\n\n        if (m > l) {\n            iter = 0;\n            do {\n                iter = iter + 1;\n\n                g = d[l];\n                p = (d[l + 1] - g) / (2 * e[l]);\n                r = hypotenuse(p, 1);\n                if (p < 0) {\n                    r = -r;\n                }\n\n                d[l] = e[l] / (p + r);\n                d[l + 1] = e[l] * (p + r);\n                dl1 = d[l + 1];\n                h = g - d[l];\n                for (i = l + 2; i < n; i++) {\n                    d[i] -= h;\n                }\n\n                f = f + h;\n\n                p = d[m];\n                c = 1;\n                c2 = c;\n                c3 = c;\n                el1 = e[l + 1];\n                s = 0;\n                s2 = 0;\n                for (i = m - 1; i >= l; i--) {\n                    c3 = c2;\n                    c2 = c;\n                    s2 = s;\n                    g = c * e[i];\n                    h = c * p;\n                    r = hypotenuse(p, e[i]);\n                    e[i + 1] = s * r;\n                    s = e[i] / r;\n                    c = p / r;\n                    p = c * d[i] - s * g;\n                    d[i + 1] = h + s * (c * g + s * d[i]);\n\n                    for (k = 0; k < n; k++) {\n                        h = V[k][i + 1];\n                        V[k][i + 1] = s * V[k][i] + c * h;\n                        V[k][i] = c * V[k][i] - s * h;\n                    }\n                }\n\n                p = -s * s2 * c3 * el1 * e[l] / dl1;\n                e[l] = s * p;\n                d[l] = c * p;\n\n            }\n            while (Math.abs(e[l]) > eps * tst1);\n        }\n        d[l] = d[l] + f;\n        e[l] = 0;\n    }\n\n    for (i = 0; i < n - 1; i++) {\n        k = i;\n        p = d[i];\n        for (j = i + 1; j < n; j++) {\n            if (d[j] < p) {\n                k = j;\n                p = d[j];\n            }\n        }\n\n        if (k !== i) {\n            d[k] = d[i];\n            d[i] = p;\n            for (j = 0; j < n; j++) {\n                p = V[j][i];\n                V[j][i] = V[j][k];\n                V[j][k] = p;\n            }\n        }\n    }\n}\n\nfunction orthes(n, H, ort, V) {\n\n    var low = 0,\n        high = n - 1,\n        f, g, h, i, j, m,\n        scale;\n\n    for (m = low + 1; m <= high - 1; m++) {\n        scale = 0;\n        for (i = m; i <= high; i++) {\n            scale = scale + Math.abs(H[i][m - 1]);\n        }\n\n        if (scale !== 0) {\n            h = 0;\n            for (i = high; i >= m; i--) {\n                ort[i] = H[i][m - 1] / scale;\n                h += ort[i] * ort[i];\n            }\n\n            g = Math.sqrt(h);\n            if (ort[m] > 0) {\n                g = -g;\n            }\n\n            h = h - ort[m] * g;\n            ort[m] = ort[m] - g;\n\n            for (j = m; j < n; j++) {\n                f = 0;\n                for (i = high; i >= m; i--) {\n                    f += ort[i] * H[i][j];\n                }\n\n                f = f / h;\n                for (i = m; i <= high; i++) {\n                    H[i][j] -= f * ort[i];\n                }\n            }\n\n            for (i = 0; i <= high; i++) {\n                f = 0;\n                for (j = high; j >= m; j--) {\n                    f += ort[j] * H[i][j];\n                }\n\n                f = f / h;\n                for (j = m; j <= high; j++) {\n                    H[i][j] -= f * ort[j];\n                }\n            }\n\n            ort[m] = scale * ort[m];\n            H[m][m - 1] = scale * g;\n        }\n    }\n\n    for (i = 0; i < n; i++) {\n        for (j = 0; j < n; j++) {\n            V[i][j] = (i === j ? 1 : 0);\n        }\n    }\n\n    for (m = high - 1; m >= low + 1; m--) {\n        if (H[m][m - 1] !== 0) {\n            for (i = m + 1; i <= high; i++) {\n                ort[i] = H[i][m - 1];\n            }\n\n            for (j = m; j <= high; j++) {\n                g = 0;\n                for (i = m; i <= high; i++) {\n                    g += ort[i] * V[i][j];\n                }\n\n                g = (g / ort[m]) / H[m][m - 1];\n                for (i = m; i <= high; i++) {\n                    V[i][j] += g * ort[i];\n                }\n            }\n        }\n    }\n}\n\nfunction hqr2(nn, e, d, V, H) {\n    var n = nn - 1,\n        low = 0,\n        high = nn - 1,\n        eps = Math.pow(2, -52),\n        exshift = 0,\n        norm = 0,\n        p = 0,\n        q = 0,\n        r = 0,\n        s = 0,\n        z = 0,\n        iter = 0,\n        i, j, k, l, m, t, w, x, y,\n        ra, sa, vr, vi,\n        notlast, cdivres;\n\n    for (i = 0; i < nn; i++) {\n        if (i < low || i > high) {\n            d[i] = H[i][i];\n            e[i] = 0;\n        }\n\n        for (j = Math.max(i - 1, 0); j < nn; j++) {\n            norm = norm + Math.abs(H[i][j]);\n        }\n    }\n\n    while (n >= low) {\n        l = n;\n        while (l > low) {\n            s = Math.abs(H[l - 1][l - 1]) + Math.abs(H[l][l]);\n            if (s === 0) {\n                s = norm;\n            }\n            if (Math.abs(H[l][l - 1]) < eps * s) {\n                break;\n            }\n            l--;\n        }\n\n        if (l === n) {\n            H[n][n] = H[n][n] + exshift;\n            d[n] = H[n][n];\n            e[n] = 0;\n            n--;\n            iter = 0;\n        } else if (l === n - 1) {\n            w = H[n][n - 1] * H[n - 1][n];\n            p = (H[n - 1][n - 1] - H[n][n]) / 2;\n            q = p * p + w;\n            z = Math.sqrt(Math.abs(q));\n            H[n][n] = H[n][n] + exshift;\n            H[n - 1][n - 1] = H[n - 1][n - 1] + exshift;\n            x = H[n][n];\n\n            if (q >= 0) {\n                z = (p >= 0) ? (p + z) : (p - z);\n                d[n - 1] = x + z;\n                d[n] = d[n - 1];\n                if (z !== 0) {\n                    d[n] = x - w / z;\n                }\n                e[n - 1] = 0;\n                e[n] = 0;\n                x = H[n][n - 1];\n                s = Math.abs(x) + Math.abs(z);\n                p = x / s;\n                q = z / s;\n                r = Math.sqrt(p * p + q * q);\n                p = p / r;\n                q = q / r;\n\n                for (j = n - 1; j < nn; j++) {\n                    z = H[n - 1][j];\n                    H[n - 1][j] = q * z + p * H[n][j];\n                    H[n][j] = q * H[n][j] - p * z;\n                }\n\n                for (i = 0; i <= n; i++) {\n                    z = H[i][n - 1];\n                    H[i][n - 1] = q * z + p * H[i][n];\n                    H[i][n] = q * H[i][n] - p * z;\n                }\n\n                for (i = low; i <= high; i++) {\n                    z = V[i][n - 1];\n                    V[i][n - 1] = q * z + p * V[i][n];\n                    V[i][n] = q * V[i][n] - p * z;\n                }\n            } else {\n                d[n - 1] = x + p;\n                d[n] = x + p;\n                e[n - 1] = z;\n                e[n] = -z;\n            }\n\n            n = n - 2;\n            iter = 0;\n        } else {\n            x = H[n][n];\n            y = 0;\n            w = 0;\n            if (l < n) {\n                y = H[n - 1][n - 1];\n                w = H[n][n - 1] * H[n - 1][n];\n            }\n\n            if (iter === 10) {\n                exshift += x;\n                for (i = low; i <= n; i++) {\n                    H[i][i] -= x;\n                }\n                s = Math.abs(H[n][n - 1]) + Math.abs(H[n - 1][n - 2]);\n                x = y = 0.75 * s;\n                w = -0.4375 * s * s;\n            }\n\n            if (iter === 30) {\n                s = (y - x) / 2;\n                s = s * s + w;\n                if (s > 0) {\n                    s = Math.sqrt(s);\n                    if (y < x) {\n                        s = -s;\n                    }\n                    s = x - w / ((y - x) / 2 + s);\n                    for (i = low; i <= n; i++) {\n                        H[i][i] -= s;\n                    }\n                    exshift += s;\n                    x = y = w = 0.964;\n                }\n            }\n\n            iter = iter + 1;\n\n            m = n - 2;\n            while (m >= l) {\n                z = H[m][m];\n                r = x - z;\n                s = y - z;\n                p = (r * s - w) / H[m + 1][m] + H[m][m + 1];\n                q = H[m + 1][m + 1] - z - r - s;\n                r = H[m + 2][m + 1];\n                s = Math.abs(p) + Math.abs(q) + Math.abs(r);\n                p = p / s;\n                q = q / s;\n                r = r / s;\n                if (m === l) {\n                    break;\n                }\n                if (Math.abs(H[m][m - 1]) * (Math.abs(q) + Math.abs(r)) < eps * (Math.abs(p) * (Math.abs(H[m - 1][m - 1]) + Math.abs(z) + Math.abs(H[m + 1][m + 1])))) {\n                    break;\n                }\n                m--;\n            }\n\n            for (i = m + 2; i <= n; i++) {\n                H[i][i - 2] = 0;\n                if (i > m + 2) {\n                    H[i][i - 3] = 0;\n                }\n            }\n\n            for (k = m; k <= n - 1; k++) {\n                notlast = (k !== n - 1);\n                if (k !== m) {\n                    p = H[k][k - 1];\n                    q = H[k + 1][k - 1];\n                    r = (notlast ? H[k + 2][k - 1] : 0);\n                    x = Math.abs(p) + Math.abs(q) + Math.abs(r);\n                    if (x !== 0) {\n                        p = p / x;\n                        q = q / x;\n                        r = r / x;\n                    }\n                }\n\n                if (x === 0) {\n                    break;\n                }\n\n                s = Math.sqrt(p * p + q * q + r * r);\n                if (p < 0) {\n                    s = -s;\n                }\n\n                if (s !== 0) {\n                    if (k !== m) {\n                        H[k][k - 1] = -s * x;\n                    } else if (l !== m) {\n                        H[k][k - 1] = -H[k][k - 1];\n                    }\n\n                    p = p + s;\n                    x = p / s;\n                    y = q / s;\n                    z = r / s;\n                    q = q / p;\n                    r = r / p;\n\n                    for (j = k; j < nn; j++) {\n                        p = H[k][j] + q * H[k + 1][j];\n                        if (notlast) {\n                            p = p + r * H[k + 2][j];\n                            H[k + 2][j] = H[k + 2][j] - p * z;\n                        }\n\n                        H[k][j] = H[k][j] - p * x;\n                        H[k + 1][j] = H[k + 1][j] - p * y;\n                    }\n\n                    for (i = 0; i <= Math.min(n, k + 3); i++) {\n                        p = x * H[i][k] + y * H[i][k + 1];\n                        if (notlast) {\n                            p = p + z * H[i][k + 2];\n                            H[i][k + 2] = H[i][k + 2] - p * r;\n                        }\n\n                        H[i][k] = H[i][k] - p;\n                        H[i][k + 1] = H[i][k + 1] - p * q;\n                    }\n\n                    for (i = low; i <= high; i++) {\n                        p = x * V[i][k] + y * V[i][k + 1];\n                        if (notlast) {\n                            p = p + z * V[i][k + 2];\n                            V[i][k + 2] = V[i][k + 2] - p * r;\n                        }\n\n                        V[i][k] = V[i][k] - p;\n                        V[i][k + 1] = V[i][k + 1] - p * q;\n                    }\n                }\n            }\n        }\n    }\n\n    if (norm === 0) {\n        return;\n    }\n\n    for (n = nn - 1; n >= 0; n--) {\n        p = d[n];\n        q = e[n];\n\n        if (q === 0) {\n            l = n;\n            H[n][n] = 1;\n            for (i = n - 1; i >= 0; i--) {\n                w = H[i][i] - p;\n                r = 0;\n                for (j = l; j <= n; j++) {\n                    r = r + H[i][j] * H[j][n];\n                }\n\n                if (e[i] < 0) {\n                    z = w;\n                    s = r;\n                } else {\n                    l = i;\n                    if (e[i] === 0) {\n                        H[i][n] = (w !== 0) ? (-r / w) : (-r / (eps * norm));\n                    } else {\n                        x = H[i][i + 1];\n                        y = H[i + 1][i];\n                        q = (d[i] - p) * (d[i] - p) + e[i] * e[i];\n                        t = (x * s - z * r) / q;\n                        H[i][n] = t;\n                        H[i + 1][n] = (Math.abs(x) > Math.abs(z)) ? ((-r - w * t) / x) : ((-s - y * t) / z);\n                    }\n\n                    t = Math.abs(H[i][n]);\n                    if ((eps * t) * t > 1) {\n                        for (j = i; j <= n; j++) {\n                            H[j][n] = H[j][n] / t;\n                        }\n                    }\n                }\n            }\n        } else if (q < 0) {\n            l = n - 1;\n\n            if (Math.abs(H[n][n - 1]) > Math.abs(H[n - 1][n])) {\n                H[n - 1][n - 1] = q / H[n][n - 1];\n                H[n - 1][n] = -(H[n][n] - p) / H[n][n - 1];\n            } else {\n                cdivres = cdiv(0, -H[n - 1][n], H[n - 1][n - 1] - p, q);\n                H[n - 1][n - 1] = cdivres[0];\n                H[n - 1][n] = cdivres[1];\n            }\n\n            H[n][n - 1] = 0;\n            H[n][n] = 1;\n            for (i = n - 2; i >= 0; i--) {\n                ra = 0;\n                sa = 0;\n                for (j = l; j <= n; j++) {\n                    ra = ra + H[i][j] * H[j][n - 1];\n                    sa = sa + H[i][j] * H[j][n];\n                }\n\n                w = H[i][i] - p;\n\n                if (e[i] < 0) {\n                    z = w;\n                    r = ra;\n                    s = sa;\n                } else {\n                    l = i;\n                    if (e[i] === 0) {\n                        cdivres = cdiv(-ra, -sa, w, q);\n                        H[i][n - 1] = cdivres[0];\n                        H[i][n] = cdivres[1];\n                    } else {\n                        x = H[i][i + 1];\n                        y = H[i + 1][i];\n                        vr = (d[i] - p) * (d[i] - p) + e[i] * e[i] - q * q;\n                        vi = (d[i] - p) * 2 * q;\n                        if (vr === 0 && vi === 0) {\n                            vr = eps * norm * (Math.abs(w) + Math.abs(q) + Math.abs(x) + Math.abs(y) + Math.abs(z));\n                        }\n                        cdivres = cdiv(x * r - z * ra + q * sa, x * s - z * sa - q * ra, vr, vi);\n                        H[i][n - 1] = cdivres[0];\n                        H[i][n] = cdivres[1];\n                        if (Math.abs(x) > (Math.abs(z) + Math.abs(q))) {\n                            H[i + 1][n - 1] = (-ra - w * H[i][n - 1] + q * H[i][n]) / x;\n                            H[i + 1][n] = (-sa - w * H[i][n] - q * H[i][n - 1]) / x;\n                        } else {\n                            cdivres = cdiv(-r - y * H[i][n - 1], -s - y * H[i][n], z, q);\n                            H[i + 1][n - 1] = cdivres[0];\n                            H[i + 1][n] = cdivres[1];\n                        }\n                    }\n\n                    t = Math.max(Math.abs(H[i][n - 1]), Math.abs(H[i][n]));\n                    if ((eps * t) * t > 1) {\n                        for (j = i; j <= n; j++) {\n                            H[j][n - 1] = H[j][n - 1] / t;\n                            H[j][n] = H[j][n] / t;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    for (i = 0; i < nn; i++) {\n        if (i < low || i > high) {\n            for (j = i; j < nn; j++) {\n                V[i][j] = H[i][j];\n            }\n        }\n    }\n\n    for (j = nn - 1; j >= low; j--) {\n        for (i = low; i <= high; i++) {\n            z = 0;\n            for (k = low; k <= Math.min(j, high); k++) {\n                z = z + V[i][k] * H[k][j];\n            }\n            V[i][j] = z;\n        }\n    }\n}\n\nfunction cdiv(xr, xi, yr, yi) {\n    var r, d;\n    if (Math.abs(yr) > Math.abs(yi)) {\n        r = yi / yr;\n        d = yr + r * yi;\n        return [(xr + r * xi) / d, (xi - r * xr) / d];\n    }\n    else {\n        r = yr / yi;\n        d = yi + r * yr;\n        return [(r * xr + xi) / d, (r * xi - xr) / d];\n    }\n}\n\nmodule.exports = EigenvalueDecomposition;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ml-matrix/src/dc/evd.js\n ** module id = 8\n ** module chunks = 0\n **/","'use strict';\n\nvar Matrix = require('../matrix');\n\n// https://github.com/lutzroeder/Mapack/blob/master/Source/LuDecomposition.cs\nfunction LuDecomposition(matrix) {\n    if (!(this instanceof LuDecomposition)) {\n        return new LuDecomposition(matrix);\n    }\n    matrix = Matrix.checkMatrix(matrix);\n\n    var lu = matrix.clone(),\n        rows = lu.rows,\n        columns = lu.columns,\n        pivotVector = new Array(rows),\n        pivotSign = 1,\n        i, j, k, p, s, t, v,\n        LUrowi, LUcolj, kmax;\n\n    for (i = 0; i < rows; i++) {\n        pivotVector[i] = i;\n    }\n\n    LUcolj = new Array(rows);\n\n    for (j = 0; j < columns; j++) {\n\n        for (i = 0; i < rows; i++) {\n            LUcolj[i] = lu[i][j];\n        }\n\n        for (i = 0; i < rows; i++) {\n            LUrowi = lu[i];\n            kmax = Math.min(i, j);\n            s = 0;\n            for (k = 0; k < kmax; k++) {\n                s += LUrowi[k] * LUcolj[k];\n            }\n            LUrowi[j] = LUcolj[i] -= s;\n        }\n\n        p = j;\n        for (i = j + 1; i < rows; i++) {\n            if (Math.abs(LUcolj[i]) > Math.abs(LUcolj[p])) {\n                p = i;\n            }\n        }\n\n        if (p !== j) {\n            for (k = 0; k < columns; k++) {\n                t = lu[p][k];\n                lu[p][k] = lu[j][k];\n                lu[j][k] = t;\n            }\n\n            v = pivotVector[p];\n            pivotVector[p] = pivotVector[j];\n            pivotVector[j] = v;\n\n            pivotSign = -pivotSign;\n        }\n\n        if (j < rows && lu[j][j] !== 0) {\n            for (i = j + 1; i < rows; i++) {\n                lu[i][j] /= lu[j][j];\n            }\n        }\n    }\n\n    this.LU = lu;\n    this.pivotVector = pivotVector;\n    this.pivotSign = pivotSign;\n}\n\nLuDecomposition.prototype = {\n    isSingular: function () {\n        var data = this.LU,\n            col = data.columns;\n        for (var j = 0; j < col; j++) {\n            if (data[j][j] === 0) {\n                return true;\n            }\n        }\n        return false;\n    },\n    get determinant() {\n        var data = this.LU;\n        if (!data.isSquare())\n            throw new Error('Matrix must be square');\n        var determinant = this.pivotSign, col = data.columns;\n        for (var j = 0; j < col; j++)\n            determinant *= data[j][j];\n        return determinant;\n    },\n    get lowerTriangularFactor() {\n        var data = this.LU,\n            rows = data.rows,\n            columns = data.columns,\n            X = new Matrix(rows, columns);\n        for (var i = 0; i < rows; i++) {\n            for (var j = 0; j < columns; j++) {\n                if (i > j) {\n                    X[i][j] = data[i][j];\n                } else if (i === j) {\n                    X[i][j] = 1;\n                } else {\n                    X[i][j] = 0;\n                }\n            }\n        }\n        return X;\n    },\n    get upperTriangularFactor() {\n        var data = this.LU,\n            rows = data.rows,\n            columns = data.columns,\n            X = new Matrix(rows, columns);\n        for (var i = 0; i < rows; i++) {\n            for (var j = 0; j < columns; j++) {\n                if (i <= j) {\n                    X[i][j] = data[i][j];\n                } else {\n                    X[i][j] = 0;\n                }\n            }\n        }\n        return X;\n    },\n    get pivotPermutationVector() {\n        return this.pivotVector.slice();\n    },\n    solve: function (value) {\n        value = Matrix.checkMatrix(value);\n\n        var lu = this.LU,\n            rows = lu.rows;\n\n        if (rows !== value.rows)\n            throw new Error('Invalid matrix dimensions');\n        if (this.isSingular())\n            throw new Error('LU matrix is singular');\n\n        var count = value.columns,\n            X = value.subMatrixRow(this.pivotVector, 0, count - 1),\n            columns = lu.columns,\n            i, j, k;\n\n        for (k = 0; k < columns; k++) {\n            for (i = k + 1; i < columns; i++) {\n                for (j = 0; j < count; j++) {\n                    X[i][j] -= X[k][j] * lu[i][k];\n                }\n            }\n        }\n        for (k = columns - 1; k >= 0; k--) {\n            for (j = 0; j < count; j++) {\n                X[k][j] /= lu[k][k];\n            }\n            for (i = 0; i < k; i++) {\n                for (j = 0; j < count; j++) {\n                    X[i][j] -= X[k][j] * lu[i][k];\n                }\n            }\n        }\n        return X;\n    }\n};\n\nmodule.exports = LuDecomposition;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ml-matrix/src/dc/lu.js\n ** module id = 9\n ** module chunks = 0\n **/","'use strict';\n\nvar Matrix = require('../matrix');\nvar hypotenuse = require('./util').hypotenuse;\n\n//https://github.com/lutzroeder/Mapack/blob/master/Source/QrDecomposition.cs\nfunction QrDecomposition(value) {\n    if (!(this instanceof QrDecomposition)) {\n        return new QrDecomposition(value);\n    }\n    value = Matrix.checkMatrix(value);\n\n    var qr = value.clone(),\n        m = value.rows,\n        n = value.columns,\n        rdiag = new Array(n),\n        i, j, k, s;\n\n    for (k = 0; k < n; k++) {\n        var nrm = 0;\n        for (i = k; i < m; i++) {\n            nrm = hypotenuse(nrm, qr[i][k]);\n        }\n        if (nrm !== 0) {\n            if (qr[k][k] < 0) {\n                nrm = -nrm;\n            }\n            for (i = k; i < m; i++) {\n                qr[i][k] /= nrm;\n            }\n            qr[k][k] += 1;\n            for (j = k + 1; j < n; j++) {\n                s = 0;\n                for (i = k; i < m; i++) {\n                    s += qr[i][k] * qr[i][j];\n                }\n                s = -s / qr[k][k];\n                for (i = k; i < m; i++) {\n                    qr[i][j] += s * qr[i][k];\n                }\n            }\n        }\n        rdiag[k] = -nrm;\n    }\n\n    this.QR = qr;\n    this.Rdiag = rdiag;\n}\n\nQrDecomposition.prototype = {\n    solve: function (value) {\n        value = Matrix.checkMatrix(value);\n\n        var qr = this.QR,\n            m = qr.rows;\n\n        if (value.rows !== m)\n            throw new Error('Matrix row dimensions must agree');\n        if (!this.isFullRank())\n            throw new Error('Matrix is rank deficient');\n\n        var count = value.columns,\n            X = value.clone(),\n            n = qr.columns,\n            i, j, k, s;\n\n        for (k = 0; k < n; k++) {\n            for (j = 0; j < count; j++) {\n                s = 0;\n                for (i = k; i < m; i++) {\n                    s += qr[i][k] * X[i][j];\n                }\n                s = -s / qr[k][k];\n                for (i = k; i < m; i++) {\n                    X[i][j] += s * qr[i][k];\n                }\n            }\n        }\n        for (k = n - 1; k >= 0; k--) {\n            for (j = 0; j < count; j++) {\n                X[k][j] /= this.Rdiag[k];\n            }\n            for (i = 0; i < k; i++) {\n                for (j = 0; j < count; j++) {\n                    X[i][j] -= X[k][j] * qr[i][k];\n                }\n            }\n        }\n\n        return X.subMatrix(0, n - 1, 0, count - 1);\n    },\n    isFullRank: function () {\n        var columns = this.QR.columns;\n        for (var i = 0; i < columns; i++) {\n            if (this.Rdiag[i] === 0) {\n                return false;\n            }\n        }\n        return true;\n    },\n    get upperTriangularFactor() {\n        var qr = this.QR,\n            n = qr.columns,\n            X = new Matrix(n, n),\n            i, j;\n        for (i = 0; i < n; i++) {\n            for (j = 0; j < n; j++) {\n                if (i < j) {\n                    X[i][j] = qr[i][j];\n                } else if (i === j) {\n                    X[i][j] = this.Rdiag[i];\n                } else {\n                    X[i][j] = 0;\n                }\n            }\n        }\n        return X;\n    },\n    get orthogonalFactor() {\n        var qr = this.QR,\n            rows = qr.rows,\n            columns = qr.columns,\n            X = new Matrix(rows, columns),\n            i, j, k, s;\n\n        for (k = columns - 1; k >= 0; k--) {\n            for (i = 0; i < rows; i++) {\n                X[i][k] = 0;\n            }\n            X[k][k] = 1;\n            for (j = k; j < columns; j++) {\n                if (qr[k][k] !== 0) {\n                    s = 0;\n                    for (i = k; i < rows; i++) {\n                        s += qr[i][k] * X[i][j];\n                    }\n\n                    s = -s / qr[k][k];\n\n                    for (i = k; i < rows; i++) {\n                        X[i][j] += s * qr[i][k];\n                    }\n                }\n            }\n        }\n        return X;\n    }\n};\n\nmodule.exports = QrDecomposition;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ml-matrix/src/dc/qr.js\n ** module id = 10\n ** module chunks = 0\n **/","'use strict';\n\nvar Matrix = require('../matrix');\n\n// https://github.com/lutzroeder/Mapack/blob/master/Source/CholeskyDecomposition.cs\nfunction CholeskyDecomposition(value) {\n    if (!(this instanceof CholeskyDecomposition)) {\n        return new CholeskyDecomposition(value);\n    }\n    value = Matrix.checkMatrix(value);\n    if (!value.isSymmetric())\n        throw new Error('Matrix is not symmetric');\n\n    var a = value,\n        dimension = a.rows,\n        l = new Matrix(dimension, dimension),\n        positiveDefinite = true,\n        i, j, k;\n\n    for (j = 0; j < dimension; j++) {\n        var Lrowj = l[j];\n        var d = 0;\n        for (k = 0; k < j; k++) {\n            var Lrowk = l[k];\n            var s = 0;\n            for (i = 0; i < k; i++) {\n                s += Lrowk[i] * Lrowj[i];\n            }\n            Lrowj[k] = s = (a[j][k] - s) / l[k][k];\n            d = d + s * s;\n        }\n\n        d = a[j][j] - d;\n\n        positiveDefinite &= (d > 0);\n        l[j][j] = Math.sqrt(Math.max(d, 0));\n        for (k = j + 1; k < dimension; k++) {\n            l[j][k] = 0;\n        }\n    }\n\n    if (!positiveDefinite) {\n        throw new Error('Matrix is not positive definite');\n    }\n\n    this.L = l;\n}\n\nCholeskyDecomposition.prototype = {\n    get leftTriangularFactor() {\n        return this.L;\n    },\n    solve: function (value) {\n        value = Matrix.checkMatrix(value);\n\n        var l = this.L,\n            dimension = l.rows;\n\n        if (value.rows !== dimension) {\n            throw new Error('Matrix dimensions do not match');\n        }\n\n        var count = value.columns,\n            B = value.clone(),\n            i, j, k;\n\n        for (k = 0; k < dimension; k++) {\n            for (j = 0; j < count; j++) {\n                for (i = 0; i < k; i++) {\n                    B[k][j] -= B[i][j] * l[k][i];\n                }\n                B[k][j] /= l[k][k];\n            }\n        }\n\n        for (k = dimension - 1; k >= 0; k--) {\n            for (j = 0; j < count; j++) {\n                for (i = k + 1; i < dimension; i++) {\n                    B[k][j] -= B[i][j] * l[i][k];\n                }\n                B[k][j] /= l[k][k];\n            }\n        }\n\n        return B;\n    }\n};\n\nmodule.exports = CholeskyDecomposition;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ml-matrix/src/dc/cholesky.js\n ** module id = 11\n ** module chunks = 0\n **/","/**\n * Created by acastillo on 8/24/15.\n */\n/**\n * Non in-place function definitions, compatible with mathjs code *\n */\n\n'use strict';\n\nvar Matrix = require('ml-matrix');\n\nfunction matrix(A,B){\n    return new Matrix(A,B);\n}\n\nfunction ones(rows, cols){\n    return Matrix.ones(rows,cols);\n}\n\nfunction eye(rows, cols){\n    return Matrix.eye(rows, cols);\n}\n\nfunction zeros(rows, cols){\n    return Matrix.zeros(rows, cols);\n}\n\nfunction random(rows, cols){\n    return Matrix.rand(rows,cols);\n}\n\nfunction transpose(A){\n    if(typeof A == 'number')\n        return A;\n    var result = A.clone();\n    return result.transpose();\n}\n\nfunction add(A, B){\n    if(typeof A == 'number'&&typeof B === 'number')\n        return A+B;\n    if(typeof A == 'number')\n        return this.add(B,A);\n\n    var result = A.clone();\n    return result.add(B);\n\n}\n\nfunction subtract(A, B){\n    if(typeof A == 'number'&&typeof B === 'number')\n        return A-B;\n    if(typeof A == 'number')\n        return this.subtract(B,A);\n    var result = A.clone();\n    return result.sub(B);\n}\n\nfunction multiply(A, B){\n    if(typeof A == 'number'&&typeof B === 'number')\n        return A*B;\n    if(typeof A == 'number')\n        return this.multiply(B,A);\n\n    var result = A.clone();\n\n    if(typeof B === 'number')\n        result.mul(B);\n    else\n        result = result.mmul(B);\n\n    if(result.rows==1&&result.columns==1)\n        return result[0][0];\n    else\n        return result;\n\n}\n\nfunction dotMultiply(A, B){\n    var result = A.clone();\n    return result.mul(B);\n}\n\nfunction dotDivide(A, B){\n    var result = A.clone();\n    return result.div(B);\n}\n\nfunction diag(A){\n    var diag = null;\n    var rows = A.rows, cols = A.columns, j, r;\n    //It is an array\n    if(typeof cols === \"undefined\" && (typeof A)=='object'){\n        if(A[0]&&A[0].length){\n            rows = A.length;\n            cols = A[0].length;\n            r = Math.min(rows,cols);\n            diag = Matrix.zeros(cols, cols);\n            for (j = 0; j < cols; j++) {\n                diag[j][j]=A[j][j];\n            }\n        }\n        else{\n            cols = A.length;\n            diag = Matrix.zeros(cols, cols);\n            for (j = 0; j < cols; j++) {\n                diag[j][j]=A[j];\n            }\n        }\n\n    }\n    if(rows == 1){\n        diag = Matrix.zeros(cols, cols);\n        for (j = 0; j < cols; j++) {\n            diag[j][j]=A[0][j];\n        }\n    }\n    else{\n        if(rows>0 && cols > 0){\n            r = Math.min(rows,cols);\n            diag = new Array(r);\n            for (j = 0; j < r; j++) {\n                diag[j] = A[j][j];\n            }\n        }\n    }\n    return diag;\n}\n\nfunction min(A, B){\n    if(typeof A==='number' && typeof B ==='number')\n        return Math.min(A,B);\n    var ii = A.rows, jj = A.columns;\n    var result = new Matrix(ii,jj);\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            if (A[i][j] < B[i][j]) {\n                result[i][j] = A[i][j];\n            }\n            else{\n                result[i][j] = B[i][j];\n            }\n        }\n    }\n    return result;\n}\n\nfunction max(A, B){\n    if(typeof A==='number' && typeof B ==='number')\n        return Math.max(A,B);\n    var ii = A.rows, jj = A.columns;\n    var result = new Matrix(ii,jj);\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            if (A[i][j] > B[i][j]) {\n                result[i][j] = A[i][j];\n            }\n            else{\n                result[i][j] = B[i][j];\n            }\n        }\n    }\n    return result;\n}\n\nfunction sqrt(A){\n    if(typeof A==='number' )\n        return Math.sqrt(A);\n    var ii = A.rows, jj = A.columns;\n    var result = new Matrix(ii,jj);\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            result[i][j] = Math.sqrt(A[i][j]);\n\n        }\n    }\n    return result;\n}\n\nfunction abs(A){\n    if(typeof A==='number' )\n        return Math.abs(A);\n    var ii = A.rows, jj = A.columns;\n    var result = new Matrix(ii,jj);\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            result[i][j] = Math.abs(A[i][j]);\n\n        }\n    }\n    return result;\n}\n\nfunction exp(A){\n    if(typeof A==='number' )\n        return Math.sqrt(A);\n    var ii = A.rows, jj = A.columns;\n    var result = new Matrix(ii,jj);\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            result[i][j] = Math.exp(A[i][j]);\n        }\n    }\n    return result;\n}\n\nfunction dotPow(A, b){\n    if(typeof A==='number' )\n        return Math.pow(A,b);\n    //console.log(A);\n    var ii = A.rows, jj = A.columns;\n    var result = new Matrix(ii,jj);\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            result[i][j] = Math.pow(A[i][j],b);\n        }\n    }\n    return result;\n}\n\nfunction solve(A, B){\n    return A.solve(B);\n}\n\nfunction inv(A){\n    if(typeof A ===\"number\")\n        return 1/A;\n    return A.inverse();\n}\n\nmodule.exports = {\n    transpose:transpose,\n    add:add,\n    subtract:subtract,\n    multiply:multiply,\n    dotMultiply:dotMultiply,\n    dotDivide:dotDivide,\n    diag:diag,\n    min:min,\n    max:max,\n    solve:solve,\n    inv:inv,\n    sqrt:sqrt,\n    exp:exp,\n    dotPow:dotPow,\n    abs:abs,\n    matrix:matrix,\n    ones:ones,\n    zeros:zeros,\n    random:random,\n    eye:eye\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ml-curve-fitting/src/algebra.js\n ** module id = 12\n ** module chunks = 0\n **/"],"sourceRoot":""}